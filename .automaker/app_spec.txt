<project_specification>
  <project_name>React Aria Components Wrapper Library</project_name>

  <overview>RAC wrapper library in Nx monorepo. Components use Slot.bind(asyncState) for async-aware rendering, useGesture/useTooltip hooks, compound patterns via Object.assign, CSS variable theming with data-* attributes.</overview>

  <technology_stack>
    <technology>React 19 canary, React Aria Components, TypeScript strict, Tailwind CSS v4, Vite, Effect, Nx, Biome, LightningCSS</technology>
    <technology>Versions in pnpm-workspace.yaml catalog - always check before adding dependencies</technology>
  </technology_stack>

  <development_guidelines>
    <guideline>Frozen B constant per file: Object.freeze({ slot: {...} })</guideline>
    <guideline>Slot.bind(asyncState) for async-aware slots in all components</guideline>
    <guideline>Required props: color, size (no defaults)</guideline>
    <guideline>Compound pattern: Object.assign(Root, { Item, Section })</guideline>
    <guideline>Hooks: useTooltip on interactive elements, useGesture for drag/slider</guideline>
    <guideline>Data attributes: data-slot, data-color, data-size, data-async-state</guideline>
    <guideline>Types from RAC: type XProps = Omit&lt;RACXProps, 'children'&gt; &amp; {...}</guideline>
    <guideline>File sections: TYPES → CONSTANTS → SUB-COMPONENTS → ENTRY_POINT → EXPORT</guideline>
    <guideline>Mode props over separate files (Progress shape="linear"|"circular" pattern)</guideline>
    <guideline>ONE LINE usage for common cases - composition only for advanced</guideline>
    <guideline>Hide internal sub-components from export</guideline>
  </development_guidelines>

  <anti_patterns>
    <item>NO hand-rolled types → derive from RAC: Omit&lt;RACXProps, 'children'&gt; &amp; {...}</item>
    <item>NO exposed internals (Thumb, Track, Cell) → auto-render within parent</item>
    <item>NO separate files for modes → unify with type prop (Field type="text|search|number")</item>
    <item>NO manual composition for basic usage → props enable features (triggerIcon={Icon})</item>
    <item>NO type-only props → every prop MUST affect output</item>
    <item>NO explicit children for simple cases → data props (colors={[...]}), children for advanced</item>
    <item>NO deep nesting (5+ levels) → max 4, use Match/dispatch tables</item>
    <item>NO nested ternaries (3+ branches) → Effect.Match.value().pipe()</item>
    <item>NO manual null checks → Option.fromNullable().pipe(Option.map, Option.getOrElse)</item>
    <item>NO hand-rolled utilities → use react-aria mergeProps/useObjectRef, Effect.Array/Record</item>
  </anti_patterns>

  <gold_standard_reference>
    <name>Button Component</name>
    <file>packages/components-next/src/actions/button.tsx</file>
    <description>Demonstrates ideal component density - maximum functionality, minimum API surface</description>
    <usage_example>
      <code><![CDATA[
<Button
  asyncState={success.state}
  children={{ default: 'Success', loading: 'Working...', success: 'Done!' }}
  prefix={{ loading: Loader2, success: Check }}
  color='primary' size='md' variant='solid'
  onPress={() => success.mutate(undefined)}
/>
      ]]></code>
    </usage_example>
    <key_patterns>
      <pattern>ONE component handles: standard press, toggle mode, async states, icons, tooltips, gestures</pattern>
      <pattern>Toggle mode auto-detected from isSelected/defaultSelected/onChange props - no separate ToggleButton</pattern>
      <pattern>Async-aware slots: children={{ default, loading, success, failure }} prefix={{ loading, success }}</pattern>
      <pattern>No manual composition required - everything flows through props</pattern>
      <pattern>168 lines total for full functionality - dense and focused</pattern>
    </key_patterns>
  </gold_standard_reference>

  <quality_gate>
    <description>Run after EVERY phase before proceeding</description>
    <commands>
      <cmd>pnpm exec nx run components-next:typecheck</cmd>
      <cmd>pnpm exec nx run components-next:check</cmd>
    </commands>
    <review>
      <item>VERIFY dense FP code - NO imperative if/else, use Match/Option/dispatch tables</item>
      <item>VERIFY all props have REAL functionality - no dead props</item>
      <item>VERIFY no handrolling - use RAC/Effect utilities</item>
      <item>REDUCE LOC where better logic achieves same output</item>
    </review>
  </quality_gate>

  <implementation_roadmap>
    <phase>
      <name>Phase 0 - Code Quality &amp; Prop Audit</name>
      <goal>Clean code before consolidation: Effect FP patterns, remove handrolling, verify prop functionality</goal>
      <files>packages/components-next/src/**/*.tsx</files>
      <tasks>
        <task>Code Cleanup - flatten nesting (max 4 levels), nested ternaries → Match, null checks → Option, if/else → dispatch tables, consolidate to B constant</task>
        <task>Remove Handrolling - audit utils against react-aria (mergeProps, useObjectRef, filterDOMProps) and Effect (Array, Record), keep only: cn(), Slot.bind(), composeTailwindRenderProps()</task>
        <task>Prop Audit - trace every prop to real output (renders UI, modifies behavior, passes to RAC, sets data-*), remove dead props, implement missing functionality</task>
        <task>Run quality_gate</task>
      </tasks>
    </phase>

    <phase>
      <name>Phase 1 - Field Unification</name>
      <goal>Unify TextField + SearchField + NumberField → single Field with type="text|search|number"</goal>
      <tasks>
        <task>Create packages/components-next/src/inputs/field.tsx - discriminated union, shared base props, mode-specific props (text: multiline/rows, search: searchIcon/clearIcon, number: incrementIcon/decrementIcon/formatOptions), data-type attribute</task>
        <task>Delete text-field.tsx, search-field.tsx, number-field.tsx</task>
        <task>Update packages/theme/src/component-wiring.ts - unified --field-* namespace with data-type overrides</task>
        <task>Update apps/test-harness/src/app.tsx - Field with type prop</task>
        <task>Run quality_gate</task>
      </tasks>
    </phase>

    <phase>
      <name>Phase 2 - Slider Simplification</name>
      <goal>Auto-render Track/Thumb - target 1 line usage</goal>
      <target><![CDATA[<Slider color='primary' size='md' defaultValue={50} thumbTooltip />
<Slider color='primary' size='md' defaultValue={[25, 75]} thumbTooltip /> <!-- range auto-detected -->]]></target>
      <tasks>
        <task>Update packages/components-next/src/inputs/slider.tsx - add thumbTooltip prop, auto-render Track+Thumb(s) when no children, detect array=range/number=single</task>
        <task>Update test-harness - one-line usage, keep one advanced Track/Thumb example</task>
        <task>Run quality_gate</task>
      </tasks>
    </phase>

    <phase>
      <name>Phase 3 - ColorPicker Simplification</name>
      <goal>Auto-render Thumb in Area/Slider/Wheel, colors prop for SwatchPicker</goal>
      <target><![CDATA[<ColorPicker.Area thumbTooltip /> <!-- auto-renders Thumb -->
<ColorPicker.SwatchPicker colors={['#ef4444', '#f97316', '#eab308']} />]]></target>
      <tasks>
        <task>Update packages/components-next/src/pickers/color-picker.tsx - thumbTooltip prop on Area/Slider/Wheel (auto-render Thumb), colors prop on SwatchPicker (auto-render items)</task>
        <task>Remove from export: Thumb, WheelTrack, SwatchPickerItem, Swatch (keep internal)</task>
        <task>Update test-harness - simplified usage</task>
        <task>Run quality_gate</task>
      </tasks>
    </phase>

    <phase>
      <name>Phase 4 - DatePicker Simplification</name>
      <goal>Auto-compose with triggerIcon prop, unify Range via mode prop - target 1 line usage</goal>
      <target><![CDATA[<DatePicker color='primary' size='md' triggerIcon={Calendar} />
<DatePicker color='primary' size='md' triggerIcon={Calendar} mode='range' />]]></target>
      <tasks>
        <task>Update packages/components-next/src/pickers/date-picker.tsx - triggerIcon prop auto-composes Field+Trigger+Popover+Calendar, mode="single|range" prop replaces DatePicker.Range</task>
        <task>Remove from export: Group, Popover, Cell, Grid, Header, HeaderCell, Segment, RangeField, RangeCalendar (keep internal)</task>
        <task>Update test-harness - one-line usage, keep one advanced composition example</task>
        <task>Run quality_gate</task>
        <task>Final audit: verify FP patterns consistent across ALL components</task>
      </tasks>
    </phase>
  </implementation_roadmap>
</project_specification>
