<project_specification>
  <project_name>React Aria Components Wrapper Library</project_name>

  <overview>RAC wrapper library in Nx monorepo. Components use Slot.bind(asyncState) for async-aware rendering, useGesture/useTooltip hooks, compound patterns via Object.assign, CSS variable theming with data-* attributes.</overview>

  <technology_stack>
    <technology>React 19 canary, React Aria Components, TypeScript strict, Tailwind CSS v4, Vite, Effect, Nx, Biome, LightningCSS</technology>
    <technology>Versions in pnpm-workspace.yaml catalog</technology>
  </technology_stack>

  <development_guidelines>
    <guideline>Frozen B constant per file: Object.freeze({ slot: {...} })</guideline>
    <guideline>Slot.bind(asyncState) for async-aware slots in all components</guideline>
    <guideline>Required props: color, size (no defaults)</guideline>
    <guideline>Compound pattern: Object.assign(Root, { Item, Section })</guideline>
    <guideline>Hooks: useTooltip on interactive elements, useGesture for drag/slider</guideline>
    <guideline>Data attributes: data-slot, data-color, data-size, data-async-state</guideline>
    <guideline>Types from RAC: type XProps = Omit&lt;RACXProps, 'children'&gt; &amp; {...}</guideline>
    <guideline>File sections: TYPES → CONSTANTS → SUB-COMPONENTS → ENTRY_POINT → EXPORT</guideline>
    <guideline>Mode props over separate files (Progress shape="linear"|"circular" pattern)</guideline>
    <guideline>ONE LINE usage for common cases - composition only for advanced</guideline>
    <guideline>Hide internal sub-components from export</guideline>
  </development_guidelines>

  <anti_patterns>
    <item>NO hand-rolled types → derive from RAC: Omit&lt;RACXProps, 'children'&gt; &amp; {...}</item>
    <item>NO exposed internal types/constats</item>
    <item>NO type-only props → every prop MUST affect output</item>
    <item>NO deep nesting (4+ levels) → max 3, use Match/dispatch tables</item>
    <item>NO nested ternaries (3+ branches) → Effect.Match.value().pipe()</item>
    <item>NO manual null checks → Option.fromNullable().pipe(Option.map, Option.getOrElse)</item>
    <item>NO hand-rolled utilities → use packages/components-next/src/core, react-aria mergeProps/useObjectRef, Effect.Array/Record</item>
  </anti_patterns>

  <gold_standard_reference>
    <name>Button Component</name>
    <file>packages/components-next/src/actions/button.tsx</file>
    <description>Demonstrates ideal component density - maximum functionality, minimum API surface</description>
    <usage_example>
      <code><![CDATA[
<Button
  asyncState={success.state}
  children={{ default: 'Success', loading: 'Working...', success: 'Done!' }}
  prefix={{ loading: Loader2, success: Check }}
  color='primary' size='md' variant='solid'
  onPress={() => success.mutate(undefined)}
/>
      ]]></code>
    </usage_example>
    <key_patterns>
      <pattern>ONE component handles: standard press, toggle mode, async states, icons, tooltips, gestures</pattern>
      <pattern>Toggle mode auto-detected from isSelected/defaultSelected/onChange props - no separate ToggleButton</pattern>
      <pattern>Async-aware slots: children={{ default, loading, success, failure }} prefix={{ loading, success }}</pattern>
      <pattern>No manual composition required - everything flows through props</pattern>
      <pattern>168 lines total for full functionality - dense and focused</pattern>
    </key_patterns>
  </gold_standard_reference>

  <quality_gate>
    <description>Run after EVERY phase before proceeding</description>
    <commands>
      <cmd>pnpm exec nx run components-next:typecheck</cmd>
      <cmd>pnpm exec nx run components-next:check</cmd>
    </commands>
    <review>
      <item>VERIFY dense FP code - NO imperative if/else, use Match/Option/dispatch tables</item>
      <item>VERIFY all props have REAL functionality - no dead props</item>
      <item>VERIFY no handrolling - use RAC/Effect utilities</item>
      <item>REDUCE LOC where better logic achieves same output</item>
    </review>
  </quality_gate>
