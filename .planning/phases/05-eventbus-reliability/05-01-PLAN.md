---
phase: 05-eventbus-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/migrations/0003_event_outbox.ts
  - packages/database/src/models.ts
  - packages/database/src/repos.ts
  - packages/database/migrations/0002_job_dlq.ts
autonomous: true

must_haves:
  truths:
    - "EventOutbox model exists with correct field types"
    - "DLQ table supports both job and event sources"
    - "Repository methods support transactional outbox pattern"
    - "eventOutbox.offer() participates in SQL transaction scope"
  artifacts:
    - path: "packages/database/migrations/0003_event_outbox.ts"
      provides: "Event outbox table with pending/published/failed status"
      contains: "CREATE TABLE event_outbox"
    - path: "packages/database/src/models.ts"
      provides: "EventOutbox Model.Class definition"
      contains: "class EventOutbox"
    - path: "packages/database/src/repos.ts"
      provides: "eventOutbox repository with offer/take/markPublished methods"
      contains: "makeEventOutboxRepo"
  key_links:
    - from: "packages/database/src/repos.ts"
      to: "packages/database/src/models.ts"
      via: "EventOutbox model import"
      pattern: "import.*EventOutbox"
    - from: "packages/database/src/repos.ts"
      to: "packages/database/migrations/0003_event_outbox.ts"
      via: "event_outbox table usage"
      pattern: "event_outbox"
---

<objective>
Database infrastructure for EventBus transactional outbox pattern.

Purpose: Enable reliable event publishing by persisting events in the same transaction as domain mutations. Events only become visible after commit, preventing phantom events on rollback.

Output:
- EventOutbox model with id, app_id, event_id, event_type, payload, status, published_at
- Migration with proper indexes, RLS, and purge function
- Repository methods for offer, take, markPublished, listPending
- DLQ table extended with source discriminator for events
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-eventbus-reliability/05-RESEARCH.md
@.planning/phases/05-eventbus-reliability/05-CONTEXT.md
@packages/database/migrations/0002_job_dlq.ts
@packages/database/src/models.ts
@packages/database/src/repos.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend DLQ table with source discriminator</name>
  <files>packages/database/migrations/0002_job_dlq.ts</files>
  <action>
Modify the existing job_dlq migration to add source column for unified DLQ:

1. Add `source TEXT NOT NULL DEFAULT 'job'` column
2. Add CHECK constraint: `source IN ('job', 'event')`
3. Add index on `(source, error_reason)` for filtered queries
4. Update error_reason CHECK to include event-specific reasons: 'DeliveryFailed', 'DeserializationFailed', 'DuplicateEvent', 'HandlerMissing', 'HandlerTimeout'

Pattern: Follow existing migration structure with SqlClient.SqlClient yield*.

Expected SQL:
- `ALTER TABLE job_dlq ADD COLUMN IF NOT EXISTS source TEXT NOT NULL DEFAULT 'job'`
- `ALTER TABLE job_dlq ADD CONSTRAINT job_dlq_source_check CHECK (source IN ('job', 'event'))`
- `CREATE INDEX idx_dlq_source ON job_dlq(source, error_reason) WHERE replayed_at IS NULL`
  </action>
  <verify>
Review the migration file to confirm source column, CHECK constraint, and index are present.
  </verify>
  <done>DLQ table supports both job and event sources with proper discrimination</done>
</task>

<task type="auto">
  <name>Task 2: Create EventOutbox model and migration</name>
  <files>packages/database/src/models.ts, packages/database/migrations/0003_event_outbox.ts</files>
  <action>
1. In models.ts, add EventOutbox model after JobDlq:

```typescript
// --- [EVENTS: EVENT_OUTBOX] --------------------------------------------------
class EventOutbox extends Model.Class<EventOutbox>('EventOutbox')({
  // IMPORTANT `UUIDv7` uuid_extract_timestamp(uuid): Extract creation time from UUIDv7 - NO created_at COLUMN
  id: Model.Generated(S.UUID),
  appId: S.UUID,                                    // Tenant scope
  eventId: S.UUID,                                  // Unique event identifier (for deduplication)
  eventType: S.String,                              // Event type: 'user.created', 'order.placed' (dot-notation)
  payload: Model.JsonFromString(S.Unknown),         // Full event envelope
  status: S.String,                                 // 'pending' | 'published' | 'failed'
  publishedAt: Model.FieldOption(S.DateFromSelf),   // When event was broadcast
}) {}
```

2. Export EventOutbox in the export statement.

3. Create migration file packages/database/migrations/0003_event_outbox.ts:

```typescript
/**
 * Migration: event_outbox - Transactional outbox for domain events.
 *
 * Purpose: Store events in same transaction as domain mutations.
 * Events become visible only after commit, preventing phantom events.
 *
 * PG18.1 + EXTENSIONS:
 * - uuidv7(): Time-ordered IDs (k-sortable, embeds creation time)
 * - uuid_extract_timestamp: Extract creation time from id (NO created_at needed)
 * - BRIN on id: Ultra-compact for time-range scans
 * - Partial indexes: Only index pending status for polling
 * - RLS: Tenant isolation via app.current_tenant GUC
 */
import { SqlClient } from '@effect/sql';
import { Effect } from 'effect';

export default Effect.gen(function* () {
  const sql = yield* SqlClient.SqlClient;

  yield* sql`
    CREATE TABLE event_outbox (
      id UUID PRIMARY KEY DEFAULT uuidv7(),
      app_id UUID NOT NULL REFERENCES apps(id) ON DELETE RESTRICT,
      event_id UUID NOT NULL UNIQUE,
      event_type TEXT NOT NULL,
      payload JSONB NOT NULL,
      status TEXT NOT NULL DEFAULT 'pending',
      published_at TIMESTAMPTZ,
      CONSTRAINT event_outbox_status_check CHECK (status IN ('pending', 'published', 'failed'))
    )
  `;

  yield* sql`COMMENT ON TABLE event_outbox IS 'Transactional outbox for domain events - use uuid_extract_timestamp(id) for creation time'`;
  yield* sql`COMMENT ON COLUMN event_outbox.event_id IS 'Unique event identifier for deduplication - generated via Snowflake'`;
  yield* sql`COMMENT ON COLUMN event_outbox.status IS 'pending = awaiting broadcast; published = successfully sent; failed = dead-lettered'`;

  // BRIN on id for time-range scans (UUIDv7 is time-ordered)
  yield* sql`CREATE INDEX idx_event_outbox_id_brin ON event_outbox USING BRIN (id)`;

  // Pending events for worker polling (most common query)
  yield* sql`CREATE INDEX idx_event_outbox_pending ON event_outbox(status, id) INCLUDE (app_id, event_type) WHERE status = 'pending'`;

  // Event lookup by event_id (deduplication check)
  yield* sql`CREATE INDEX idx_event_outbox_event_id ON event_outbox(event_id)`;

  // Failed events by type for debugging
  yield* sql`CREATE INDEX idx_event_outbox_failed ON event_outbox(event_type, id DESC) WHERE status = 'failed'`;

  // FK enforcement
  yield* sql`CREATE INDEX idx_event_outbox_app_id_fk ON event_outbox(app_id)`;

  // Purge function for published events
  yield* sql`
    CREATE OR REPLACE FUNCTION purge_event_outbox(p_older_than_days INT DEFAULT 7)
    RETURNS INT
    LANGUAGE sql
    AS $$
      WITH purged AS (
        DELETE FROM event_outbox
        WHERE status = 'published'
          AND published_at < NOW() - (p_older_than_days || ' days')::interval
        RETURNING id
      )
      SELECT COUNT(*)::int FROM purged
    $$
  `;
  yield* sql`COMMENT ON FUNCTION purge_event_outbox IS 'Hard-delete published events older than N days - keeps pending and failed'`;

  // RLS for tenant isolation
  yield* sql`ALTER TABLE event_outbox ENABLE ROW LEVEL SECURITY`;
  yield* sql`CREATE POLICY event_outbox_tenant_isolation ON event_outbox USING (app_id = current_setting('app.current_tenant', true)::uuid) WITH CHECK (app_id = current_setting('app.current_tenant', true)::uuid)`;
  yield* sql`ALTER TABLE event_outbox FORCE ROW LEVEL SECURITY`;
  yield* sql`COMMENT ON POLICY event_outbox_tenant_isolation ON event_outbox IS 'RLS: Isolate event_outbox by app_id matching current_setting(app.current_tenant)'`;
});
```

Pattern: Follow 0002_job_dlq.ts structure with header comments, BRIN indexes, RLS, purge function.
  </action>
  <verify>
1. Check models.ts exports EventOutbox
2. Check migration file exists with CREATE TABLE, indexes, RLS, purge function
3. Run `pnpm exec nx run database:typecheck` to verify no type errors
  </verify>
  <done>EventOutbox model and migration created with proper indexes and RLS</done>
</task>

<task type="auto">
  <name>Task 3: Create eventOutbox repository with transactional integration</name>
  <files>packages/database/src/repos.ts</files>
  <action>
Add eventOutbox repository to repos.ts with explicit transactional semantics:

1. Add import for EventOutbox in the models import statement.

2. Add repository factory after makeKvStoreRepo:

```typescript
// --- [EVENT_OUTBOX_REPO] -----------------------------------------------------

const makeEventOutboxRepo = Effect.gen(function* () {
  const r = yield* repo(EventOutbox, 'event_outbox', {
    conflict: { keys: ['eventId'], only: [] },  // Dedupe by eventId - reject duplicates
    purge: 'purge_event_outbox',
    resolve: { byEventId: 'eventId' },
  });
  return {
    ...r,
    byEventId: (eventId: string) => r.by('byEventId', eventId),
    countPending: () => r.count([{ field: 'status', value: 'pending' }]),
    listPending: (limit = 100) => r.page([{ field: 'status', value: 'pending' }], { limit }),
    markFailed: (id: string) => r.set(id, { status: 'failed' }),
    markPublished: (id: string) => r.set(id, { published_at: Update.now, status: 'published' }),
    /**
     * Offer event to outbox - MUST be called within db.transaction() scope.
     *
     * CRITICAL: This insert participates in the current SQL transaction.
     * Events become visible only after transaction commits, preventing phantom events.
     *
     * Usage:
     * ```typescript
     * yield* db.transaction(Effect.gen(function* () {
     *   yield* db.orders.insert(order);
     *   yield* db.eventOutbox.offer({ appId, eventId, eventType: 'order.placed', payload });
     * }));
     * ```
     */
    offer: (event: { appId: string; eventId: string; eventType: string; payload: unknown }) =>
      r.insert({ appId: event.appId, eventId: event.eventId, eventType: event.eventType, payload: event.payload, status: 'pending' }),
    /**
     * Take pending events for broadcast - used by outbox worker.
     * Returns events in FIFO order (by id, which is UUIDv7 time-ordered).
     */
    takePending: (limit = 100) => r.page([{ field: 'status', value: 'pending' }], { limit, order: 'asc' }),
  };
});
```

3. Add eventOutbox to DatabaseService effect:

- Add `eventOutbox` to the Effect.all array
- Add `eventOutbox` to the return object

4. Add deadLetter alias for unified access (if not exists):

```typescript
// In DatabaseService return, ensure deadLetter maps to jobDlq for unified DLQ access
deadLetter: {
  insert: (entry: { appId: string; source: 'job' | 'event'; sourceId: string; type: string; payload: unknown; errorReason: string; attempts: number; errorHistory: readonly { error: string; timestamp: number }[] }) =>
    jobDlq.insert({ ...entry, originalJobId: entry.sourceId }),
}
```

Verify jobDlq insert handles source field from DLQ extension in Task 1.
  </action>
  <verify>
1. Run `pnpm exec nx run database:typecheck` to verify no type errors
2. Check that DatabaseService exports eventOutbox property
3. Verify offer() has JSDoc explaining transactional requirement
  </verify>
  <done>eventOutbox repository with offer, listPending, takePending, markPublished methods ready for EventBus with documented transaction semantics</done>
</task>

</tasks>

<verification>
1. `pnpm exec nx run database:typecheck` - No type errors
2. EventOutbox model exported from models.ts
3. Migration file 0003_event_outbox.ts exists with CREATE TABLE, indexes, RLS
4. job_dlq migration includes source column with CHECK constraint
5. DatabaseService.eventOutbox available with offer, listPending, takePending, markPublished methods
6. offer() method has JSDoc documenting transactional requirement
</verification>

<success_criteria>
- EventOutbox model defined with id, appId, eventId, eventType, payload, status, publishedAt
- Migration creates event_outbox table with BRIN index, partial indexes for pending status, RLS
- Repository supports offer (insert pending), listPending, takePending, markPublished, markFailed
- offer() method participates in SQL transaction scope (documented in JSDoc)
- DLQ table extended to support source = 'event' for unified dead-letter handling
- All database types compile successfully
</success_criteria>

<output>
After completion, create `.planning/phases/05-eventbus-reliability/05-01-SUMMARY.md`
</output>
