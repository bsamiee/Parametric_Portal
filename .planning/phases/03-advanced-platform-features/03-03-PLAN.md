---
phase: 03-advanced-platform-features
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - packages/server/src/platform/workers/pool.ts
autonomous: true

must_haves:
  truths:
    - "WorkerPoolService is an Effect.Service class"
    - "Fixed pool of workers (4) with concurrency 1 per worker"
    - "parse() method returns Stream of progress/result"
    - "Soft timeout signals checkpoint, grace period before kill"
    - "Full observability via MetricsService (queue depth, active workers, latencies)"
  artifacts:
    - path: "packages/server/src/platform/workers/pool.ts"
      provides: "WorkerPoolService for managing transfer parsing workers"
      exports: ["WorkerPoolService"]
  key_links:
    - from: "packages/server/src/platform/workers/pool.ts"
      to: "packages/server/src/platform/workers/contract.ts"
      via: "import TransferRpc, ParseTransfer"
      pattern: "TransferRpc"
    - from: "packages/server/src/platform/workers/pool.ts"
      to: "packages/server/src/observe/metrics.ts"
      via: "MetricsService integration"
      pattern: "MetricsService"
    - from: "WorkerPoolService.parse"
      to: "Worker pool"
      via: "RpcClient dispatch"
      pattern: "client\\(new ParseTransfer"
---

<objective>
Create WorkerPoolService that manages a fixed pool of workers for transfer parsing operations.

Purpose: Provide the main thread service that orchestrates parsing operations across worker threads. This service exposes a simple `parse()` method that returns a Stream of progress updates and the final result.

Output:
- `pool.ts` with WorkerPoolService Effect.Service class
- Fixed pool size (4 workers, concurrency 1)
- Soft timeout + grace period handling
- Full metrics integration
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-advanced-platform-features/03-CONTEXT.md
@.planning/phases/03-advanced-platform-features/03-RESEARCH.md
@.planning/phases/03-advanced-platform-features/03-01-SUMMARY.md
@.planning/phases/03-advanced-platform-features/03-02-SUMMARY.md
@packages/server/src/platform/workers/contract.ts
@packages/server/src/observe/metrics.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkerPoolService</name>
  <files>packages/server/src/platform/workers/pool.ts</files>
  <action>
Create `packages/server/src/platform/workers/pool.ts` - the main thread service managing worker pool:

1. **Imports:**
   ```typescript
   import * as NodeWorker from "@effect/platform-node/NodeWorker";
   import * as RpcClient from "@effect/rpc/RpcClient";
   import { Data, Duration, Effect, Fiber, Layer, Option, Stream } from "effect";
   import { TransferRpc, ParseTransfer, ParseProgress, ParseResult, TimeoutError, WorkerCrashError, type ParseFormat } from "./contract.ts";
   import { MetricsService } from "../../observe/metrics.ts";
   ```

2. **CONSTANTS section:**
   ```typescript
   const _Pool = {
     size: 4,              // Fixed pool of 4 workers
     concurrency: 1,       // One parse per worker at a time
     softTimeout: Duration.minutes(5),
     gracePeriod: Duration.seconds(30),
   } as const;
   ```

3. **ERRORS section:**
   ```typescript
   class PoolError extends Data.TaggedError('PoolError')<{
     readonly cause: unknown;
     readonly operation: string;
   }> {
     override get message() { return `PoolError: ${this.operation} - ${String(this.cause)}`; }
   }
   ```

4. **METRICS section:** Add worker pool metrics to track:
   ```typescript
   const _metrics = {
     active: (m: typeof MetricsService.Type) => m.jobs.queueDepth, // Reuse existing gauge
     duration: (m: typeof MetricsService.Type) => m.transfer.duration,
     errors: (m: typeof MetricsService.Type) => m.errors,
   } as const;
   ```

5. **SERVICE section:**
   ```typescript
   class WorkerPoolService extends Effect.Service<WorkerPoolService>()(
     "server/WorkerPoolService",
     {
       dependencies: [],
       scoped: Effect.gen(function* () {
         // Create RPC protocol layer for worker pool
         const workerPath = new URL('./transfer.ts', import.meta.url).pathname;

         // Note: Actual worker spawning happens lazily via RpcClient
         // The layer provides the protocol configuration

         yield* Effect.logInfo('WorkerPoolService initialized', {
           poolSize: _Pool.size,
           concurrency: _Pool.concurrency,
         });

         return {
           _config: _Pool,
           _workerPath: workerPath,
         };
       }),
     },
   ) {
   ```

6. **PARSE method:** Static method for parsing with progress:
   ```typescript
   static readonly parse = (presignedUrl: string, format: ParseFormat) =>
     Effect.gen(function* () {
       const state = yield* WorkerPoolService;
       const metricsOpt = yield* Effect.serviceOption(MetricsService);

       // Create RPC client with worker pool
       const RpcProtocol = RpcClient.layerProtocolWorker({
         size: state._config.size,
         concurrency: state._config.concurrency,
       }).pipe(
         Layer.provide(NodeWorker.layer(() => new Worker(state._workerPath))),
         Layer.orDie,
       );

       const client = yield* RpcClient.make(TransferRpc).pipe(
         Effect.provide(RpcProtocol),
       );

       // Track start time for metrics
       const startTime = Date.now();
       const labels = MetricsService.label({ format, operation: 'parse' });

       // Dispatch to worker with soft timeout handling
       const parseStream = client(new ParseTransfer({ presignedUrl, format }));

       // Wrap with timeout and metrics
       return parseStream.pipe(
         // Add soft timeout with grace period
         Stream.timeoutFail(() => new TimeoutError({
           elapsed: Duration.millis(Date.now() - startTime),
           softLimit: state._config.softTimeout,
           hardLimit: Duration.sum(state._config.softTimeout, state._config.gracePeriod),
         }), Duration.sum(state._config.softTimeout, state._config.gracePeriod)),

         // Track duration on completion
         Stream.ensuring(Effect.gen(function* () {
           const elapsed = Date.now() - startTime;
           yield* Effect.transposeMapOption(metricsOpt, (m) =>
             Effect.all([
               MetricsService.inc(_metrics.duration(m), labels),
             ], { discard: true }),
           );
           yield* Effect.logDebug('Parse completed', { elapsed, format });
         })),
       );
     });
   ```

7. **HEALTH method:** Check worker pool status:
   ```typescript
   static readonly health = () =>
     Effect.gen(function* () {
       yield* WorkerPoolService;
       // Workers are lazily spawned, so health is about service availability
       return { available: true, poolSize: _Pool.size };
     });
   ```

8. **LAYER section:**
   ```typescript
   static readonly Layer = WorkerPoolService.Default;
   ```

9. **NAMESPACE section:**
   ```typescript
   namespace WorkerPoolService {
     export type Error = PoolError | TimeoutError | WorkerCrashError;
   }
   ```

10. **EXPORT section:**
    ```typescript
    export { WorkerPoolService };
    ```

Key implementation notes:
- RpcClient.layerProtocolWorker handles pool management
- Workers are stateless - each request gets fresh worker from pool
- Soft timeout via Stream.timeoutFail
- MetricsService integration via serviceOption (optional dependency)
- Worker path resolved via import.meta.url
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
WorkerPoolService compiles with parse() and health() methods.
  </verify>
  <done>
- WorkerPoolService is Effect.Service class with scoped initialization
- Fixed pool size of 4 workers with concurrency 1
- parse(presignedUrl, format) returns Stream of ParseProgress | ParseResult
- Soft timeout + grace period handling via Stream.timeoutFail
- MetricsService integration for duration tracking
- Worker path resolved correctly for spawning
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Worker Pool Metrics</name>
  <files>packages/server/src/observe/metrics.ts</files>
  <action>
Extend MetricsService to include worker pool specific metrics:

1. **Add to metrics object** (in the `effect: Effect.succeed({...})` block):
   ```typescript
   workers: {
     active: Metric.gauge('workers_active'),
     completions: Metric.counter('workers_completions_total'),
     crashes: Metric.counter('workers_crashes_total'),
     duration: Metric.timerWithBoundaries('workers_duration_seconds', _boundaries.transfer),
     queueDepth: Metric.gauge('workers_queue_depth'),
     timeouts: Metric.counter('workers_timeouts_total'),
   },
   ```

2. **Ensure _boundaries.transfer exists** (it does in current file):
   ```typescript
   transfer: [0.1, 0.5, 2.5, 12.5, 62.5, 312.5] as const,
   ```

This enables full observability per CONTEXT.md:
- Queue depth: workers_queue_depth gauge
- Active workers: workers_active gauge
- Latencies: workers_duration_seconds histogram
- Failures: workers_crashes_total, workers_timeouts_total counters
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
MetricsService.Type includes workers property with all metrics.
  </verify>
  <done>
- MetricsService includes workers.active gauge
- MetricsService includes workers.queueDepth gauge
- MetricsService includes workers.duration histogram
- MetricsService includes workers.completions counter
- MetricsService includes workers.crashes counter
- MetricsService includes workers.timeouts counter
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **TypeScript compilation:**
   ```bash
   pnpm exec nx run server:typecheck
   ```

2. **Service structure:**
   - WorkerPoolService.parse() returns Stream
   - WorkerPoolService.health() returns status
   - WorkerPoolService.Layer available

3. **Metrics integration:**
   - workers.* metrics defined
   - Labels include format, operation

4. **Biome formatting:**
   ```bash
   pnpm exec nx run server:lint
   ```
</verification>

<success_criteria>
- WorkerPoolService compiles as Effect.Service
- parse() method returns Stream<ParseProgress | ParseResult>
- Fixed pool configuration (4 workers, concurrency 1)
- Timeout handling with soft/hard limits
- Worker pool metrics added to MetricsService
- No circular dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-advanced-platform-features/03-03-SUMMARY.md`
</output>
