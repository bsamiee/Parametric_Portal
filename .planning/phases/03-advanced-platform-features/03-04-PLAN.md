---
phase: 03-advanced-platform-features
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - packages/server/src/main.ts
  - packages/server/src/http/api.ts
autonomous: false

must_haves:
  truths:
    - "WorkerPoolService.Layer composed in main.ts"
    - "API health endpoint responds under 100ms during heavy parsing"
    - "Transfer parsing operations use WorkerPoolService"
    - "Existing transfer functionality preserved (backward compatible)"
  artifacts:
    - path: "packages/server/src/main.ts"
      provides: "Layer composition including WorkerPoolService"
      contains: "WorkerPoolService"
  key_links:
    - from: "packages/server/src/main.ts"
      to: "packages/server/src/platform/workers/pool.ts"
      via: "Layer composition"
      pattern: "WorkerPoolService\\.Layer"
---

<objective>
Integrate WorkerPoolService into the application and verify non-blocking API behavior.

Purpose: Complete the worker pool integration by composing the service layer and verifying that the health endpoint remains responsive during heavy parsing operations.

Output:
- WorkerPoolService composed in main.ts layer stack
- Health endpoint verification under load
- Transfer API optionally using worker pool for parsing
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-advanced-platform-features/03-CONTEXT.md
@.planning/phases/03-advanced-platform-features/03-RESEARCH.md
@.planning/phases/03-advanced-platform-features/03-01-SUMMARY.md
@.planning/phases/03-advanced-platform-features/03-02-SUMMARY.md
@.planning/phases/03-advanced-platform-features/03-03-SUMMARY.md
@packages/server/src/platform/workers/pool.ts
@packages/server/src/main.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Compose WorkerPoolService in Main</name>
  <files>packages/server/src/main.ts</files>
  <action>
Add WorkerPoolService to the application layer composition in `packages/server/src/main.ts`:

1. **Add import:**
   ```typescript
   import { WorkerPoolService } from './platform/workers/pool.ts';
   ```

2. **Compose layer** in the appropriate location (Platform layer):
   Find the layer composition section and add WorkerPoolService.Layer:
   ```typescript
   // In the Platform layer composition (alongside CacheService, MetricsService, etc.)
   Layer.provideMerge(WorkerPoolService.Layer),
   ```

3. **Ensure proper ordering:**
   - WorkerPoolService depends on MetricsService (optional)
   - WorkerPoolService should be in Platform layer (infrastructure-level service)
   - Should be after MetricsService in composition order

4. **Register cache schemas** for session/token (if applicable):
   At application startup (after services initialized):
   ```typescript
   // Register schema domains for typed cache access
   yield* CacheService.register('session', SessionSchema);
   yield* CacheService.register('token', TokenSchema);
   ```
   (Only if SessionSchema and TokenSchema are defined - check codebase)

Note: The exact layer composition structure depends on current main.ts organization. Follow the existing pattern for adding new services.
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
pnpm exec nx run server:build
```
Application compiles with WorkerPoolService in layer stack.
  </verify>
  <done>
- WorkerPoolService.Layer composed in main.ts
- Import added for WorkerPoolService
- Layer ordering correct (after MetricsService)
- Application compiles and builds successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Health Endpoint Worker Status</name>
  <files>packages/server/src/http/api.ts</files>
  <action>
Extend the health endpoint to include worker pool status:

1. **Find existing health endpoint** (likely `/health` or `/api/health`)

2. **Add WorkerPoolService health check:**
   ```typescript
   // In health endpoint handler
   const workerHealth = yield* WorkerPoolService.health().pipe(
     Effect.catchAll(() => Effect.succeed({ available: false, poolSize: 0 })),
   );
   ```

3. **Include in health response:**
   ```typescript
   return {
     // ... existing health checks ...
     workers: workerHealth,
   };
   ```

4. **Ensure non-blocking:**
   - WorkerPoolService.health() should be fast (no I/O)
   - Use Effect.timeout if needed to guarantee <100ms

If no health endpoint exists, create one:
```typescript
HttpApiEndpoint.get("health", "/health")
  .addSuccess(Schema.Struct({
    status: Schema.Literal("ok"),
    cache: Schema.Struct({ l1: Schema.Boolean, l2: Schema.Boolean }),
    workers: Schema.Struct({ available: Schema.Boolean, poolSize: Schema.Number }),
  }))
```
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
Health endpoint includes worker status.
  </verify>
  <done>
- Health endpoint returns worker pool status
- Response includes { workers: { available: boolean, poolSize: number } }
- Health check is non-blocking (<100ms)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
WorkerPoolService integrated into application with health monitoring.

Components completed:
1. RPC contract schemas (03-01)
2. Worker script with parsing (03-02)
3. WorkerPoolService main thread service (03-03)
4. Layer composition and health endpoint (03-04)
  </what-built>
  <how-to-verify>
1. **Start the server:**
   ```bash
   pnpm exec nx run server:dev
   ```

2. **Check health endpoint:**
   ```bash
   curl http://localhost:3000/health
   ```
   Expected: Response includes `workers: { available: true, poolSize: 4 }`

3. **Verify non-blocking behavior:**
   - In one terminal, trigger a large file parse (if API endpoint exists)
   - In another terminal, repeatedly check health:
   ```bash
   for i in {1..10}; do
     time curl -s http://localhost:3000/health > /dev/null
   done
   ```
   Expected: Each health check completes in <100ms

4. **Check logs for worker pool initialization:**
   Look for: "WorkerPoolService initialized" with poolSize and concurrency

5. **Verify no errors:**
   - No TypeScript errors during compilation
   - No runtime errors on startup
   - Worker pool logs show successful initialization
  </how-to-verify>
  <resume-signal>Type "approved" if health endpoint responds quickly and worker status is correct, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Application startup:**
   ```bash
   pnpm exec nx run server:dev
   ```
   No errors, WorkerPoolService initialized

2. **Health endpoint:**
   ```bash
   curl http://localhost:3000/health
   ```
   Returns JSON with workers status

3. **Success criteria from ROADMAP.md:**
   - "API health endpoint responds under 100ms during heavy transfer parsing operations"
</verification>

<success_criteria>
- WorkerPoolService.Layer in main.ts composition
- Health endpoint includes worker pool status
- Health response time <100ms (non-blocking)
- Application starts without errors
- Human verification confirms expected behavior
</success_criteria>

<output>
After completion, create `.planning/phases/03-advanced-platform-features/03-04-SUMMARY.md`
</output>
