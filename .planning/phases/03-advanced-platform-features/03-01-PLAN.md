---
phase: 03-advanced-platform-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/platform/workers/contract.ts
  - packages/server/src/platform/cache.ts
autonomous: true

must_haves:
  truths:
    - "ParseProgress and ParseResult schemas exist with proper fields"
    - "Error union includes ParseError, TimeoutError, WorkerCrashError"
    - "CacheService.register(domain, schema) stores schema at startup"
    - "CacheService.getSchema(domain, key) returns typed Option"
    - "Decode failure on cached value returns Option.none (cache miss)"
  artifacts:
    - path: "packages/server/src/platform/workers/contract.ts"
      provides: "RPC contract schemas for worker communication"
      exports: ["ParseProgress", "ParseResult", "ParseTransfer", "TransferRpc"]
    - path: "packages/server/src/platform/cache.ts"
      provides: "forSchema extension methods"
      contains: "register"
  key_links:
    - from: "contract.ts"
      to: "@effect/rpc"
      via: "Rpc.StreamRequest, RpcGroup.make"
      pattern: "Rpc\\.StreamRequest"
    - from: "cache.ts"
      to: "@effect/platform KeyValueStore"
      via: "forSchema integration"
      pattern: "forSchema|SchemaStore"
---

<objective>
Create RPC contract schemas for worker communication and extend CacheService with schema-validated typed access.

Purpose: Establish the type contracts that enable type-safe worker communication and compile-time validated cache entries. These are foundational pieces that other plans depend on.

Output:
- `contract.ts` with ParseProgress, ParseResult, error schemas, and RpcGroup
- CacheService extended with `register()` and `getSchema()` methods
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-advanced-platform-features/03-CONTEXT.md
@.planning/phases/03-advanced-platform-features/03-RESEARCH.md
@packages/server/src/platform/cache.ts
@packages/server/src/utils/transfer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RPC Contract Schemas</name>
  <files>packages/server/src/platform/workers/contract.ts</files>
  <action>
Create `packages/server/src/platform/workers/contract.ts` following CLAUDE.md section organization:

1. **TYPES section:** Infer types from schemas (no separate type declarations)

2. **SCHEMA section:**
   - `ParseProgress`: Schema.Struct with bytesProcessed (Number), totalBytes (Number), rowsProcessed (Number), percentage (Number), eta (Schema.Option(Schema.Number))
   - `ParseResult`: Schema.Struct with items (Array of {content: String, type: String, ordinal: Number}), errors (Array of {code: String, ordinal: Number, detail: Schema.Option(String)})
   - `ParseFormat`: Schema.Literal("xlsx", "csv", "zip", "json", "yaml", "xml", "ndjson")

3. **ERRORS section:**
   - `ParseError`: Data.TaggedError with code (Schema.Literal of DECOMPRESS | HASH_MISMATCH | INVALID_PATH | INVALID_RECORD | MISSING_TYPE | SCHEMA_MISMATCH | TOO_LARGE), ordinal (Schema.optional(Number)), detail (Schema.optional(String))
   - `TimeoutError`: Data.TaggedError with elapsed (Duration), softLimit (Duration), hardLimit (Duration)
   - `WorkerCrashError`: Data.TaggedError with workerId (String), reason (String)
   - Create union: `TransferWorkerError = ParseError | TimeoutError | WorkerCrashError`

4. **RPC section:**
   - Use `Rpc.StreamRequest` pattern from research:
   ```typescript
   class ParseTransfer extends Rpc.StreamRequest<ParseTransfer>()(
     "ParseTransfer",
     {
       payload: { presignedUrl: S.String, format: ParseFormat },
       success: S.Union(ParseProgress, ParseResult),
       failure: TransferWorkerError,
     },
   ) {}
   ```
   - Create RpcGroup: `class TransferRpc extends RpcGroup.make(ParseTransfer) {}`

5. **EXPORT section:** Named exports only (ParseProgress, ParseResult, ParseFormat, ParseError, TimeoutError, WorkerCrashError, TransferWorkerError, ParseTransfer, TransferRpc)

Follow codebase conventions:
- Use `Schema as S` import alias
- Section separators: `// --- [SECTION] ` + dashes to column 80
- No barrel files, direct imports
- Derive types with `typeof XSchema.Type`
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
File exists at expected path with all exports.
  </verify>
  <done>
- ParseProgress, ParseResult, ParseFormat schemas defined with all required fields
- ParseError, TimeoutError, WorkerCrashError as Data.TaggedError
- ParseTransfer as Rpc.StreamRequest with proper payload/success/failure
- TransferRpc as RpcGroup containing ParseTransfer
- All types inferred from schemas, no duplicate type declarations
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend CacheService with forSchema</name>
  <files>packages/server/src/platform/cache.ts</files>
  <action>
Extend existing CacheService in `packages/server/src/platform/cache.ts` with schema-validated access:

1. **Add module-level registry** (after _Cache constants):
   ```typescript
   const _domains = new Map<string, S.Schema<unknown, unknown>>();
   ```

2. **Add static method `register`** (after `health` method):
   ```typescript
   static readonly register = <A, I>(domain: string, schema: S.Schema<A, I>) =>
     Effect.sync(() => { _domains.set(domain, schema as S.Schema<unknown, unknown>); });
   ```
   Purpose: Register domain schemas at application startup.

3. **Add static method `getSchema`** (after `register`):
   Implement typed cache get with decode-failure-as-miss semantics:
   ```typescript
   static readonly getSchema = <A, I>(domain: string) => (key: string): Effect.Effect<Option.Option<A>, Resilience.Error<never>, CacheService> =>
     Effect.gen(function* () {
       const schema = _domains.get(domain) as S.Schema<A, I> | undefined;
       if (!schema) return Option.none<A>();

       const state = yield* CacheService;
       const ctx = yield* Context.Request.current;
       const userSuffix = Option.match(ctx.session, { onNone: () => '', onSome: (s) => `:${s.userId}` });
       const scopedKey = `${state._prefix}${ctx.tenantId}${userSuffix}:${domain}:${key}`;

       // Try L2 directly (schema stores bypass L1 Effect.Cache)
       const raw = yield* Effect.tryPromise({
         catch: () => 'L2Miss' as const,
         try: () => state._pub.get(scopedKey)
       }).pipe(Effect.orElseSucceed(() => null));

       if (raw === null) return Option.none<A>();

       // Decode with failure = cache miss (per CONTEXT.md decision)
       return yield* S.decodeUnknown(S.parseJson(schema))(raw).pipe(
         Effect.map(Option.some),
         Effect.catchTag('ParseError', () => Effect.succeed(Option.none<A>())),
       );
     });
   ```

4. **Add static method `setSchema`** (after `getSchema`):
   ```typescript
   static readonly setSchema = <A, I>(domain: string, ttlOverride?: Duration.Duration) =>
     (key: string, value: A): Effect.Effect<void, CacheError, CacheService> =>
       Effect.gen(function* () {
         const schema = _domains.get(domain) as S.Schema<A, I> | undefined;
         if (!schema) return;

         const state = yield* CacheService;
         const ctx = yield* Context.Request.current;
         const userSuffix = Option.match(ctx.session, { onNone: () => '', onSome: (s) => `:${s.userId}` });
         const scopedKey = `${state._prefix}${ctx.tenantId}${userSuffix}:${domain}:${key}`;

         const encoded = yield* S.encode(schema)(value).pipe(Effect.orDie);
         const ttlSeconds = ttlOverride
           ? Math.floor(Duration.toMillis(ttlOverride) / 1000)
           : _Cache.defaults.ttlSeconds;

         yield* Effect.tryPromise({
           catch: (e) => new CacheError({ cause: e, operation: 'redis-set-schema' }),
           try: () => state._pub.setex(scopedKey, ttlSeconds, JSON.stringify(encoded)),
         });
       });
   ```

5. **Update namespace** to export new types if needed.

Constraints:
- No new helper functions (polymorphic unity)
- Use existing _Cache constants for TTL
- Match existing code style (Effect.gen, pipe patterns)
- Maintain existing imports, add Schema import if not present
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
CacheService.register, CacheService.getSchema, CacheService.setSchema methods exist and compile.
  </verify>
  <done>
- _domains Map exists for schema registration
- CacheService.register(domain, schema) stores schema in _domains
- CacheService.getSchema(domain)(key) returns Option.none on decode failure (cache miss semantics)
- CacheService.setSchema(domain, ttlOverride?)(key, value) encodes and stores with optional TTL override
- Auto-scoping from FiberRef (tenantId + userId) applied to schema stores
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **TypeScript compilation:**
   ```bash
   pnpm exec nx run server:typecheck
   ```

2. **Contract exports:**
   - contract.ts exports: ParseProgress, ParseResult, ParseFormat, ParseError, TimeoutError, WorkerCrashError, ParseTransfer, TransferRpc

3. **CacheService methods:**
   - register, getSchema, setSchema methods exist on CacheService class

4. **Biome formatting:**
   ```bash
   pnpm exec nx run server:lint
   ```
</verification>

<success_criteria>
- RPC contract schemas compile and export correctly
- CacheService extended with register/getSchema/setSchema
- Decode failure returns Option.none (verified by type signature)
- No new helper functions added (polymorphic unity maintained)
- Typecheck passes for server package
</success_criteria>

<output>
After completion, create `.planning/phases/03-advanced-platform-features/03-01-SUMMARY.md`
</output>
