---
phase: 01-cluster-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/infra/cluster.ts
autonomous: true

must_haves:
  truths:
    - "ClusterService exports single const + namespace merge under 225 LOC"
    - "ClusterError with 11 variants (AlreadyProcessingMessage, EntityNotAssignedToRunner, MailboxFull, MalformedMessage, PersistenceError, RunnerNotRegistered, RunnerUnavailable, SendTimeout, Suspended, RpcClientError, SerializationError) and static factory methods"
    - "Entity schema uses Snowflake.SnowflakeFromString for entity ID serialization"
    - "Entity schema defined with Rpc.make for polymorphic message routing"
    - "Match.value(error.reason) used for error discrimination (no instanceof)"
  artifacts:
    - path: "packages/server/src/infra/cluster.ts"
      provides: "ClusterService facade with send/broadcast/singleton operations"
      exports: ["ClusterService"]
      max_lines: 225
  key_links:
    - from: "packages/server/src/infra/cluster.ts"
      to: "existing circuit.ts error patterns"
      via: "Match.value on error.reason field for ClusterError discrimination"
      pattern: "Match\\.value\\(error\\.reason\\)"
---

<objective>
Create the ClusterService facade with Entity schema definitions and typed ClusterError handling.

Purpose: Establish the foundational cluster abstraction that all subsequent plans build upon. Single import point for all cluster operations following the codebase's const + namespace merge pattern.

Output: `packages/server/src/infra/cluster.ts` with ClusterService, ClusterError, and Entity schema definitions.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cluster-foundation/01-CONTEXT.md
@.planning/phases/01-cluster-foundation/01-RESEARCH.md
@packages/server/src/utils/circuit.ts
@packages/server/src/errors.ts
@packages/server/src/observe/metrics.ts
@REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClusterService file with Entity schema and ClusterError</name>
  <files>packages/server/src/infra/cluster.ts</files>
  <action>
Create new file `packages/server/src/infra/cluster.ts` following the exact codebase conventions:

**File Structure** (use standard section separators):
- `// --- [SCHEMA] ----------------------------------------------------------------`
- `// --- [ERRORS] ----------------------------------------------------------------`
- `// --- [CONSTANTS] -------------------------------------------------------------`
- `// --- [SERVICES] --------------------------------------------------------------`
- `// --- [ENTRY_POINT] ----------------------------------------------------------`
- `// --- [NAMESPACE] -------------------------------------------------------------`
- `// --- [EXPORT] ----------------------------------------------------------------`

**[SCHEMA] Section:**
Define polymorphic Entity message types using `Rpc.make` from `@effect/cluster`:

```typescript
import { Entity, Rpc, Snowflake } from '@effect/cluster';
import { Duration, Schema as S } from 'effect';

// Branded type for idempotency keys with validation
const IdempotencyKey = S.String.pipe(
  S.minLength(1),
  S.maxLength(255),
  S.pattern(/^[a-zA-Z0-9:_-]+$/),
  S.brand('IdempotencyKey'),
);
type IdempotencyKey = typeof IdempotencyKey.Type;

// Message payload schemas using Schema.Class for opacity + methods
// Note: Schema.Class auto-generates validated make() constructor - no custom one needed
class ProcessPayload extends S.Class<ProcessPayload>('ProcessPayload')({
  entityId: Snowflake.SnowflakeFromString,  // Use SnowflakeFromString for external string input
  data: S.Unknown,
  idempotencyKey: S.optional(IdempotencyKey),
}) {}

class StatusPayload extends S.Class<StatusPayload>('StatusPayload')({
  entityId: Snowflake.SnowflakeFromString,
}) {}

class StatusResponse extends S.Class<StatusResponse>('StatusResponse')({
  status: S.Literal('idle', 'processing', 'complete', 'failed'),
  updatedAt: S.Number,
}) {}
```

**[ERRORS] Section:**
Create ClusterError using Schema.TaggedError for RPC boundary serialization (follows errors.ts pattern):

```typescript
import { Match, Schema as S } from 'effect';

// Schema.TaggedError for cross-process RPC boundary (serializable)
// Data.TaggedError is for internal errors only - Entity RPC needs serialization
// Include ALL @effect/cluster error variants for complete error handling
class ClusterError extends S.TaggedError<ClusterError>()('ClusterError', {
  cause: S.optional(S.Unknown),
  reason: S.Literal(
    'AlreadyProcessingMessage',   // Entity currently handling a request
    'EntityNotAssignedToRunner',  // Message for unmanaged entity (replaces EntityNotManagedByRunner in 3.19)
    'MailboxFull',                // Entity mailbox at capacity
    'MalformedMessage',           // Deserialization failure
    'PersistenceError',           // Storage backend error
    'RunnerNotRegistered',        // Runner not in cluster
    'RunnerUnavailable',          // Runner offline
    'SendTimeout',                // Message delivery timeout
    'Suspended',                  // Entity suspended awaiting signal (Phase 6 DurableDeferred compatibility)
    'RpcClientError',             // Wraps RpcClientError for Phase 7 WebSocket RPC failures
    'SerializationError',         // MsgPack/JSON decode failures
  ),
  entityId: S.optional(S.String),
  resumeToken: S.optional(S.String),  // Enable manual resume via DurableDeferred pattern (Phase 6)
  requestId: S.optional(S.String),    // (#R2) RPC request ID for correlation/distributed tracing
}) {
  // Factory methods for all @effect/cluster error variants
  static readonly fromAlreadyProcessing = (entityId: string, cause?: unknown) =>
    new ClusterError({ cause, entityId, reason: 'AlreadyProcessingMessage' });
  static readonly fromEntityNotAssigned = (entityId: string, cause?: unknown) =>
    new ClusterError({ cause, entityId, reason: 'EntityNotAssignedToRunner' });
  static readonly fromMailboxFull = (entityId: string, cause?: unknown) =>
    new ClusterError({ cause, entityId, reason: 'MailboxFull' });
  static readonly fromMalformedMessage = (cause?: unknown) =>
    new ClusterError({ cause, reason: 'MalformedMessage' });
  static readonly fromPersistence = (cause?: unknown) =>
    new ClusterError({ cause, reason: 'PersistenceError' });
  static readonly fromRunnerNotRegistered = (cause?: unknown) =>
    new ClusterError({ cause, reason: 'RunnerNotRegistered' });
  static readonly fromRunnerUnavailable = (entityId: string, cause?: unknown) =>
    new ClusterError({ cause, entityId, reason: 'RunnerUnavailable' });
  static readonly fromSendTimeout = (entityId: string, cause?: unknown) =>
    new ClusterError({ cause, entityId, reason: 'SendTimeout' });
  static readonly fromSuspended = (entityId: string, resumeToken: string) =>
    new ClusterError({ entityId, reason: 'Suspended', resumeToken });
  // (#R2) Factory for wrapping RpcClientError (Phase 7 WebSocket RPC)
  static readonly fromRpcClientError = (entityId: string, cause: unknown, requestId?: string) =>
    new ClusterError({ cause, entityId, reason: 'RpcClientError', requestId });
  static readonly fromSerializationError = (cause?: unknown) =>
    new ClusterError({ cause, reason: 'SerializationError' });

  // Note: Manual .is guards removed - Schema.TaggedError provides automatic
  // discrimination via Match.valueTags or Effect.catchTag with e.reason
}
```

**Error handling pattern** (use Match.value with e.reason - all 11 variants for exhaustive):
```typescript
const handleError = (error: ClusterError) =>
  Match.value(error.reason).pipe(
    Match.when('AlreadyProcessingMessage', () => /* retry later */),
    Match.when('EntityNotAssignedToRunner', () => /* route to correct runner */),
    Match.when('MailboxFull', () => /* back-pressure, retry with backoff */),
    Match.when('MalformedMessage', () => /* log and fail */),
    Match.when('PersistenceError', () => /* log and fail */),
    Match.when('RunnerNotRegistered', () => /* wait for runner registration */),
    Match.when('RunnerUnavailable', () => /* failover */),
    Match.when('SendTimeout', () => /* retry with backoff */),
    Match.when('Suspended', () => /* resume via DurableDeferred token */),
    Match.when('RpcClientError', () => /* handle RPC failure */),
    Match.when('SerializationError', () => /* log and fail */),
    Match.exhaustive,
  );
```

**[CONSTANTS] Section:**
Define configuration constants using `as const`:

```typescript
const _CONFIG = {
  entity: {
    maxIdleTime: Duration.minutes(5),
    concurrency: 1,
    mailboxCapacity: 100,  // Explicit capacity - prevents OOM
  },
  sla: {
    sendTimeout: Duration.millis(100),  // ROADMAP truth: "Entity message sent on Pod A reaches handler on Pod B within 100ms"
  },
  retry: {
    transient: {
      base: Duration.millis(50),
      maxAttempts: 3,  // For MailboxFull, SendTimeout
    },
    defect: {
      base: Duration.millis(100),
      factor: 2,
      maxAttempts: 5,  // For entity defect recovery
    },
  },
} as const;
```

**[SERVICES] Section:**
Stub the ClusterService as Effect.Service (full implementation in Plan 02):

```typescript
class ClusterService extends Effect.Service<ClusterService>()('server/Cluster', {
  effect: Effect.gen(function* () {
    // Dependencies will be added in Plan 02
    return {
      send: <R>(entityId: string, request: R) => Effect.fail(new Error('Not implemented')),
      broadcast: (entityType: string, request: unknown) => Effect.fail(new Error('Not implemented')),
      isLocal: (entityId: string) => Effect.succeed(false),
    };
  }),
}) {}
```

**[ENTRY_POINT] Section:**
Create const + namespace merge:

```typescript
// biome-ignore lint/correctness/noUnusedVariables: const+namespace merge pattern
const ClusterService = {
  Error: ClusterError,
  // Service class methods will be merged
} as const;
```

**[NAMESPACE] Section:**
Export types via namespace:

```typescript
namespace ClusterService {
  export type Error = InstanceType<typeof ClusterError>;
  export type ErrorReason = Error['reason'];
  export type Config = typeof _CONFIG;
}
```

**Critical Requirements:**
- Use `Match.value(error).pipe(Match.when(ClusterError.is.mailboxFull, ...), ...)` for error handling - NEVER instanceof
- Follow existing `circuit.ts` error factory pattern exactly
- Keep file under 225 LOC (stub implementation, full in Plan 02)
- Use branded types for EntityId
  </action>
  <verify>
Run typecheck to ensure no type errors:
```bash
pnpm exec nx run server:typecheck
```
Verify file exists and is under 225 lines:
```bash
wc -l packages/server/src/infra/cluster.ts
```
  </verify>
  <done>
- ClusterService file exists at `packages/server/src/infra/cluster.ts`
- ClusterError with static factory methods and `.is` type guards
- Entity schema with Rpc.make message types defined
- File passes typecheck
- File under 225 LOC
  </done>
</task>

<task type="auto">
  <name>Task 2: Add error handling utility with Match.type pattern</name>
  <files>packages/server/src/infra/cluster.ts</files>
  <action>
Add a utility function for ClusterError handling using Match.type (following codebase convention from circuit.ts):

In the `// --- [FUNCTIONS] ----------------------------------------------------------------` section (add after CONSTANTS):

```typescript
// Handler interface covers all 11 ClusterError variants for Match.exhaustive
const _handleClusterError = <A>(error: ClusterError, handlers: {
  readonly onAlreadyProcessing: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onEntityNotAssigned: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onMailboxFull: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onMalformedMessage: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onPersistence: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onRunnerNotRegistered: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onRunnerUnavailable: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onSendTimeout: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onSuspended: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onRpcClientError: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onSerializationError: (e: ClusterError) => Effect.Effect<A, never, never>;
}): Effect.Effect<A, never, never> => Match.value(error.reason).pipe(
  Match.when('AlreadyProcessingMessage', () => handlers.onAlreadyProcessing(error)),
  Match.when('EntityNotAssignedToRunner', () => handlers.onEntityNotAssigned(error)),
  Match.when('MailboxFull', () => handlers.onMailboxFull(error)),
  Match.when('MalformedMessage', () => handlers.onMalformedMessage(error)),
  Match.when('PersistenceError', () => handlers.onPersistence(error)),
  Match.when('RunnerNotRegistered', () => handlers.onRunnerNotRegistered(error)),
  Match.when('RunnerUnavailable', () => handlers.onRunnerUnavailable(error)),
  Match.when('SendTimeout', () => handlers.onSendTimeout(error)),
  Match.when('Suspended', () => handlers.onSuspended(error)),
  Match.when('RpcClientError', () => handlers.onRpcClientError(error)),
  Match.when('SerializationError', () => handlers.onSerializationError(error)),
  Match.exhaustive,
);
```

This utility:
- Uses Match.value on error.reason (Schema.TaggedError discriminant)
- Match.exhaustive ensures all 11 cases handled (compile error if missing)
- Returns Effect for composability
- TypeScript infers correct types in each branch

Also add a simpler error classification function for metrics:

```typescript
const _errorTag = (error: ClusterError): string => error.reason;
```

Export `handleError` via the ClusterService const object:

```typescript
const ClusterService = {
  Error: ClusterError,
  handleError: _handleClusterError,
  errorTag: _errorTag,
} as const;
```
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
Grep for instanceof to ensure it's not used:
```bash
grep -n "instanceof" packages/server/src/infra/cluster.ts || echo "No instanceof found - good"
```
  </verify>
  <done>
- _handleClusterError utility function exists
- Uses Match.value/Match.when pattern
- No instanceof checks in file
- Exported via ClusterService.handleError
  </done>
</task>

</tasks>

<verification>
Overall verification for Plan 01:

1. **File exists and typechecks:**
   ```bash
   pnpm exec nx run server:typecheck
   ```

2. **File follows conventions:**
   - Check section separators present
   - Check const + namespace merge pattern
   - Check under 225 LOC

3. **No forbidden patterns:**
   ```bash
   grep -n "instanceof" packages/server/src/infra/cluster.ts && echo "FAIL: instanceof found" || echo "PASS: no instanceof"
   grep -n "if.*else" packages/server/src/infra/cluster.ts && echo "FAIL: if/else found" || echo "PASS: no if/else"
   ```

4. **Exports correct:**
   ```bash
   grep -n "export { ClusterService }" packages/server/src/infra/cluster.ts
   ```
</verification>

<success_criteria>
- [ ] `packages/server/src/infra/cluster.ts` exists
- [ ] File typechecks without errors
- [ ] ClusterError uses Schema.TaggedError for RPC boundary serialization
- [ ] ClusterError has static factory methods (fromMailboxFull, fromPersistence, etc.)
- [ ] Schema.Class used for ProcessPayload, StatusPayload, StatusResponse (not S.Struct)
- [ ] Snowflake.schema used for entityId (not hand-rolled brand)
- [ ] Match.value(error.reason) used for error handling (no manual .is guards)
- [ ] const + namespace merge pattern used
- [ ] File under 225 LOC
- [ ] All section separators present per codebase convention
</success_criteria>

<output>
After completion, create `.planning/phases/01-cluster-foundation/01-01-SUMMARY.md`
</output>
