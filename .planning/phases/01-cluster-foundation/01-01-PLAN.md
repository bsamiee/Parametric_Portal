---
phase: 01-cluster-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/infra/cluster.ts
autonomous: true

must_haves:
  truths:
    - "ClusterService exports single const + namespace merge under 225 LOC"
    - "ClusterError type guards used for typed error handling (no instanceof checks)"
    - "Entity schema defined with Rpc.make for polymorphic message routing"
  artifacts:
    - path: "packages/server/src/infra/cluster.ts"
      provides: "ClusterService facade with send/broadcast/singleton operations"
      exports: ["ClusterService"]
      max_lines: 225
  key_links:
    - from: "packages/server/src/infra/cluster.ts"
      to: "existing circuit.ts error patterns"
      via: "Match.type for ClusterError discrimination"
      pattern: "Match\\.value\\(error\\)\\.pipe"
---

<objective>
Create the ClusterService facade with Entity schema definitions and typed ClusterError handling.

Purpose: Establish the foundational cluster abstraction that all subsequent plans build upon. Single import point for all cluster operations following the codebase's const + namespace merge pattern.

Output: `packages/server/src/infra/cluster.ts` with ClusterService, ClusterError, and Entity schema definitions.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cluster-foundation/01-CONTEXT.md
@.planning/phases/01-cluster-foundation/01-RESEARCH.md
@packages/server/src/utils/circuit.ts
@packages/server/src/errors.ts
@packages/server/src/observe/metrics.ts
@REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClusterService file with Entity schema and ClusterError</name>
  <files>packages/server/src/infra/cluster.ts</files>
  <action>
Create new file `packages/server/src/infra/cluster.ts` following the exact codebase conventions:

**File Structure** (use standard section separators):
- `// --- [SCHEMA] ----------------------------------------------------------------`
- `// --- [ERRORS] ----------------------------------------------------------------`
- `// --- [CONSTANTS] -------------------------------------------------------------`
- `// --- [SERVICES] --------------------------------------------------------------`
- `// --- [ENTRY_POINT] ----------------------------------------------------------`
- `// --- [NAMESPACE] -------------------------------------------------------------`
- `// --- [EXPORT] ----------------------------------------------------------------`

**[SCHEMA] Section:**
Define polymorphic Entity message types using `Rpc.make` from `@effect/cluster`:

```typescript
import { Entity, Rpc } from '@effect/cluster';
import { Schema as S } from 'effect';

// Message payload schemas
const ProcessPayload = S.Struct({
  entityId: S.String.pipe(S.brand('EntityId')),
  data: S.Unknown,
  idempotencyKey: S.optional(S.String),
});

const StatusPayload = S.Struct({
  entityId: S.String.pipe(S.brand('EntityId')),
});

const StatusResponse = S.Struct({
  status: S.Literal('idle', 'processing', 'complete', 'failed'),
  updatedAt: S.Number,
});
```

**[ERRORS] Section:**
Create ClusterError following existing `circuit.ts` Data.TaggedError pattern:

```typescript
import { Data, Match } from 'effect';

class ClusterError extends Data.TaggedError('ClusterError')<{
  readonly cause: unknown;
  readonly reason: 'MailboxFull' | 'PersistenceError' | 'RunnerUnavailable' | 'SendTimeout' | 'Unknown';
  readonly entityId?: string;
}> {
  static readonly fromMailboxFull = (entityId: string, cause: unknown) =>
    new ClusterError({ cause, entityId, reason: 'MailboxFull' });
  static readonly fromPersistence = (cause: unknown) =>
    new ClusterError({ cause, reason: 'PersistenceError' });
  static readonly fromRunnerUnavailable = (entityId: string, cause: unknown) =>
    new ClusterError({ cause, entityId, reason: 'RunnerUnavailable' });
  static readonly fromSendTimeout = (entityId: string, cause: unknown) =>
    new ClusterError({ cause, entityId, reason: 'SendTimeout' });
  static readonly fromUnknown = (cause: unknown) =>
    new ClusterError({ cause, reason: 'Unknown' });

  // Type guard using static `.is()` pattern - NO instanceof checks
  static readonly is = {
    mailboxFull: (e: ClusterError): e is ClusterError & { reason: 'MailboxFull' } => e.reason === 'MailboxFull',
    persistence: (e: ClusterError): e is ClusterError & { reason: 'PersistenceError' } => e.reason === 'PersistenceError',
    runnerUnavailable: (e: ClusterError): e is ClusterError & { reason: 'RunnerUnavailable' } => e.reason === 'RunnerUnavailable',
    sendTimeout: (e: ClusterError): e is ClusterError & { reason: 'SendTimeout' } => e.reason === 'SendTimeout',
  };

  override get message() {
    return this.entityId
      ? `Cluster[${this.entityId}]: ${this.reason}`
      : `Cluster: ${this.reason}`;
  }
}
```

**[CONSTANTS] Section:**
Define configuration constants using `as const`:

```typescript
const _CONFIG = {
  entity: {
    maxIdleTime: Duration.minutes(5),
    concurrency: 1,
    mailboxCapacity: 100,  // Explicit capacity - prevents OOM
  },
  retry: {
    base: Duration.millis(100),
    factor: 2,
    maxAttempts: 5,
  },
} as const;
```

**[SERVICES] Section:**
Stub the ClusterService as Effect.Service (full implementation in Plan 02):

```typescript
class ClusterService extends Effect.Service<ClusterService>()('server/Cluster', {
  effect: Effect.gen(function* () {
    // Dependencies will be added in Plan 02
    return {
      send: <R>(entityId: string, request: R) => Effect.fail(new Error('Not implemented')),
      broadcast: (entityType: string, request: unknown) => Effect.fail(new Error('Not implemented')),
      isLocal: (entityId: string) => Effect.succeed(false),
    };
  }),
}) {}
```

**[ENTRY_POINT] Section:**
Create const + namespace merge:

```typescript
// biome-ignore lint/correctness/noUnusedVariables: const+namespace merge pattern
const ClusterService = {
  Error: ClusterError,
  // Service class methods will be merged
} as const;
```

**[NAMESPACE] Section:**
Export types via namespace:

```typescript
namespace ClusterService {
  export type Error = InstanceType<typeof ClusterError>;
  export type ErrorReason = Error['reason'];
  export type Config = typeof _CONFIG;
}
```

**Critical Requirements:**
- Use `Match.value(error).pipe(Match.when(ClusterError.is.mailboxFull, ...), ...)` for error handling - NEVER instanceof
- Follow existing `circuit.ts` error factory pattern exactly
- Keep file under 225 LOC (stub implementation, full in Plan 02)
- Use branded types for EntityId
  </action>
  <verify>
Run typecheck to ensure no type errors:
```bash
pnpm exec nx run server:typecheck
```
Verify file exists and is under 225 lines:
```bash
wc -l packages/server/src/infra/cluster.ts
```
  </verify>
  <done>
- ClusterService file exists at `packages/server/src/infra/cluster.ts`
- ClusterError with static factory methods and `.is` type guards
- Entity schema with Rpc.make message types defined
- File passes typecheck
- File under 225 LOC
  </done>
</task>

<task type="auto">
  <name>Task 2: Add error handling utility with Match.type pattern</name>
  <files>packages/server/src/infra/cluster.ts</files>
  <action>
Add a utility function for ClusterError handling using Match.type (following codebase convention from circuit.ts):

In the `// --- [FUNCTIONS] ----------------------------------------------------------------` section (add after CONSTANTS):

```typescript
const _handleClusterError = <A>(error: ClusterError, handlers: {
  readonly onMailboxFull: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onPersistence: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onRunnerUnavailable: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onSendTimeout: (e: ClusterError) => Effect.Effect<A, never, never>;
  readonly onUnknown: (e: ClusterError) => Effect.Effect<A, never, never>;
}): Effect.Effect<A, never, never> => Match.value(error).pipe(
  Match.when(ClusterError.is.mailboxFull, handlers.onMailboxFull),
  Match.when(ClusterError.is.persistence, handlers.onPersistence),
  Match.when(ClusterError.is.runnerUnavailable, handlers.onRunnerUnavailable),
  Match.when(ClusterError.is.sendTimeout, handlers.onSendTimeout),
  Match.orElse(handlers.onUnknown),
);
```

This utility:
- Uses Match.value + Match.when pattern (no if/else chains)
- Uses static `.is` guards (no instanceof)
- Returns Effect for composability
- Exhaustive handling via Match.orElse

Also add a simpler error classification function for metrics:

```typescript
const _errorTag = (error: ClusterError): string => error.reason;
```

Export `handleError` via the ClusterService const object:

```typescript
const ClusterService = {
  Error: ClusterError,
  handleError: _handleClusterError,
  errorTag: _errorTag,
} as const;
```
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
Grep for instanceof to ensure it's not used:
```bash
grep -n "instanceof" packages/server/src/infra/cluster.ts || echo "No instanceof found - good"
```
  </verify>
  <done>
- _handleClusterError utility function exists
- Uses Match.value/Match.when pattern
- No instanceof checks in file
- Exported via ClusterService.handleError
  </done>
</task>

</tasks>

<verification>
Overall verification for Plan 01:

1. **File exists and typechecks:**
   ```bash
   pnpm exec nx run server:typecheck
   ```

2. **File follows conventions:**
   - Check section separators present
   - Check const + namespace merge pattern
   - Check under 225 LOC

3. **No forbidden patterns:**
   ```bash
   grep -n "instanceof" packages/server/src/infra/cluster.ts && echo "FAIL: instanceof found" || echo "PASS: no instanceof"
   grep -n "if.*else" packages/server/src/infra/cluster.ts && echo "FAIL: if/else found" || echo "PASS: no if/else"
   ```

4. **Exports correct:**
   ```bash
   grep -n "export { ClusterService }" packages/server/src/infra/cluster.ts
   ```
</verification>

<success_criteria>
- [ ] `packages/server/src/infra/cluster.ts` exists
- [ ] File typechecks without errors
- [ ] ClusterError has static factory methods (fromMailboxFull, fromPersistence, etc.)
- [ ] ClusterError has static `.is` type guards
- [ ] Match.value/Match.when used for error handling (no instanceof)
- [ ] const + namespace merge pattern used
- [ ] File under 225 LOC
- [ ] All section separators present per codebase convention
</success_criteria>

<output>
After completion, create `.planning/phases/01-cluster-foundation/01-01-SUMMARY.md`
</output>
