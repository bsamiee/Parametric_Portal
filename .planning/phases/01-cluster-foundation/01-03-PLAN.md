---
phase: 01-cluster-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/server/src/observe/metrics.ts
autonomous: true

must_haves:
  truths:
    - "Cluster state gauges (effect_cluster_*) provided by @effect/cluster/ClusterMetrics, auto-exported via OTLP"
    - "App-specific cluster counters/histograms defined in MetricsService.cluster namespace"
    - "ClusterError metrics labeled by error type (MailboxFull, RunnerUnavailable, etc.)"
    - "Entity lifecycle metrics (activations, deactivations, lifetime) for capacity planning"
    - "Metrics follow existing MetricsService.label pattern"
  artifacts:
    - path: "packages/server/src/observe/metrics.ts"
      provides: "App-specific cluster metrics (counters/histograms) integrated with MetricsService"
      contains: "cluster:"
  key_links:
    - from: "packages/server/src/observe/metrics.ts"
      to: "packages/server/src/infra/cluster.ts"
      via: "ClusterService.errorTag for error classification"
      pattern: "cluster\\.errors"
    - from: "packages/server/src/observe/metrics.ts"
      to: "packages/server/src/infra/cluster.ts"
      via: "Entity lifecycle tracking (activate/deactivate hooks)"
      pattern: "entityActivations|entityDeactivations"
---

<objective>
Add app-specific cluster metrics to MetricsService for operational observability.

Purpose: @effect/cluster/ClusterMetrics provides state gauges (entities, runners, shards) automatically via Sharding internals. We add app-specific metrics for message throughput, latency, and error rates by type. All metrics export via existing Telemetry.Default OTLP layer.

Output: Updated `packages/server/src/observe/metrics.ts` with cluster metrics namespace (counters/histograms only).
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cluster-foundation/01-CONTEXT.md
@.planning/phases/01-cluster-foundation/01-RESEARCH.md
@packages/server/src/observe/metrics.ts
@packages/server/src/infra/cluster.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cluster metrics namespace to MetricsService</name>
  <files>packages/server/src/observe/metrics.ts</files>
  <action>
Update `packages/server/src/observe/metrics.ts` to add cluster-specific metrics.

**Add to _boundaries constant (after existing boundaries):**
```typescript
const _boundaries = {
  http:       [0.001, 0.01, 0.1, 1, 10, 100] as const,
  jobs:       [0.01, 0.1, 1, 10, 100, 1000] as const,
  // ... existing boundaries ...
  cluster:    [0.001, 0.01, 0.05, 0.1, 0.5, 1, 5] as const,  // Message latency (target <100ms)
} as const;
```

**Add cluster namespace to MetricsService effect (inside the Effect.succeed block, after existing namespaces):**

Find the existing `effect: Effect.succeed({` block and add after the `workers:` namespace:

```typescript
// NOTE: @effect/cluster/ClusterMetrics provides these gauges automatically:
// - effect_cluster_entities, effect_cluster_singletons, effect_cluster_runners,
// - effect_cluster_runners_healthy, effect_cluster_shards
// These are auto-updated by Sharding internals and exported via Telemetry.Default OTLP layer.
// We only define APP-SPECIFIC metrics below (counters/histograms that ClusterMetrics doesn't provide).

cluster: {
  // Counters for app-level operations (ClusterMetrics doesn't track these)
  messagesSent: Metric.counter('cluster_messages_sent_total'),
  messagesReceived: Metric.counter('cluster_messages_received_total'),
  redeliveries: Metric.counter('cluster_redeliveries_total'),

  // (#15) Entity lifecycle metrics - important for capacity planning and debugging idle timeout
  entityActivations: Metric.counter('cluster_entity_activations_total'),
  entityDeactivations: Metric.counter('cluster_entity_deactivations_total'),

  // Histogram for message latency (SLA target: <100ms)
  messageLatency: Metric.timerWithBoundaries('cluster_message_latency_seconds', _boundaries.cluster),

  // (#16) Entity lifetime histogram - helps tune maxIdleTime settings
  entityLifetime: Metric.timerWithBoundaries('cluster_entity_lifetime_seconds',
    [1, 5, 30, 60, 300, 600, 1800, 3600]),  // Up to 1 hour

  // Error counter - labeled by type (MailboxFull, RunnerUnavailable, etc.)
  errors: Metric.counter('cluster_errors_total'),
},
```

**Metrics purpose:**

*Provided by @effect/cluster/ClusterMetrics (auto-updated by Sharding, exported via OTLP):*
- `effect_cluster_entities`: Current entity count (bigint gauge)
- `effect_cluster_singletons`: Singleton instance count (bigint gauge)
- `effect_cluster_runners`: Registered runner count (bigint gauge)
- `effect_cluster_runners_healthy`: Healthy runner count (bigint gauge)
- `effect_cluster_shards`: Total shard count (bigint gauge)

*App-specific metrics (defined in MetricsService.cluster):*
- `cluster_messages_sent_total`: Messages sent counter (labels: entity_type)
- `cluster_messages_received_total`: Messages received counter (labels: entity_type)
- `cluster_redeliveries_total`: Message redelivery counter
- `cluster_entity_activations_total`: Entity activation counter (capacity planning)
- `cluster_entity_deactivations_total`: Entity deactivation counter (capacity planning)
- `cluster_message_latency_seconds`: Message delivery latency histogram
- `cluster_entity_lifetime_seconds`: Entity lifetime histogram (helps tune maxIdleTime)
- `cluster_errors_total`: Error counter (labels: type - MailboxFull, PersistenceError, etc.)

**Labeling pattern:**
Cluster metrics use the existing `MetricsService.label({ type: 'MailboxFull' })` pattern for error type discrimination.
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
Verify cluster namespace exists:
```bash
grep -n "cluster:" packages/server/src/observe/metrics.ts
grep -n "cluster_entities" packages/server/src/observe/metrics.ts
grep -n "cluster_errors" packages/server/src/observe/metrics.ts
```
  </verify>
  <done>
- cluster namespace added to MetricsService effect
- Gauges for entities, runners, shards
- Counters for messages, redeliveries, errors
- Histogram for message latency
- _boundaries.cluster defined for SLA-aligned buckets
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cluster error tracking utility</name>
  <files>packages/server/src/observe/metrics.ts</files>
  <action>
Add a utility method for tracking cluster errors with type labels. This integrates with the existing `MetricsService.trackEffect` pattern.

**Add static method to MetricsService class (after trackStreamProgress):**

```typescript
/** Track cluster operation with error classification */
static readonly trackCluster = <A, E extends { readonly reason: string }, R>(
  effect: Effect.Effect<A, E, R>,
  config: {
    readonly operation: 'send' | 'broadcast' | 'receive';
    readonly entityType: string;
  },
): Effect.Effect<A, E, R | MetricsService> =>
  Effect.gen(function* () {
    const metrics = yield* MetricsService;
    const labels = MetricsService.label({
      entity_type: config.entityType,
      operation: config.operation,
    });
    return yield* effect.pipe(
      // Use Match.value instead of nested ternary (CLAUDE.md: prefer Match.type)
      Effect.tap(() => Match.value(config.operation).pipe(
        Match.when('send', () => Metric.increment(Metric.taggedWithLabels(metrics.cluster.messagesSent, labels))),
        Match.when('receive', () => Metric.increment(Metric.taggedWithLabels(metrics.cluster.messagesReceived, labels))),
        Match.when('broadcast', () => Effect.void),
        Match.exhaustive,
      )),
      Metric.trackDuration(Metric.taggedWithLabels(metrics.cluster.messageLatency, labels)),
      Effect.tapError((e) => {
        const errorLabels = MetricsService.label({
          entity_type: config.entityType,
          type: e.reason,  // ClusterError.reason: 'MailboxFull' | 'RunnerUnavailable' | etc.
        });
        return Metric.increment(Metric.taggedWithLabels(metrics.cluster.errors, errorLabels));
      }),
    );
  }).pipe(Effect.flatten);
```

**Usage pattern** (will be used in cluster.ts):
```typescript
// In ClusterService.send:
MetricsService.trackCluster(
  sharding.send(entity, request),
  { operation: 'send', entityType: 'Cluster' },
)
```

This utility:
- Increments message counters (sent/received based on operation)
- Tracks message latency via histogram
- Increments error counter with type label on failure
- Uses `e.reason` for error classification (works with ClusterError)
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
Verify trackCluster method:
```bash
grep -n "trackCluster" packages/server/src/observe/metrics.ts
```
  </verify>
  <done>
- MetricsService.trackCluster static method added
- Tracks message counts by operation type
- Tracks message latency histogram
- Tracks errors by type (e.reason)
- Uses existing MetricsService.label pattern
  </done>
</task>

</tasks>

<verification>
Overall verification for Plan 03:

1. **Typecheck passes:**
   ```bash
   pnpm exec nx run server:typecheck
   ```

2. **App-specific cluster metrics present (not duplicating ClusterMetrics gauges):**
   ```bash
   grep -n "cluster:" packages/server/src/observe/metrics.ts
   grep -n "cluster_messages_sent" packages/server/src/observe/metrics.ts
   grep -n "cluster_errors" packages/server/src/observe/metrics.ts
   grep -n "cluster_message_latency" packages/server/src/observe/metrics.ts
   # Should NOT find effect_cluster_* - those are provided by ClusterMetrics automatically
   grep -n "effect_cluster" packages/server/src/observe/metrics.ts && echo "WARN: duplicating ClusterMetrics" || echo "PASS: no duplication"
   ```

3. **trackCluster utility:**
   ```bash
   grep -n "trackCluster" packages/server/src/observe/metrics.ts
   ```

4. **Boundaries defined:**
   ```bash
   grep -n "_boundaries.cluster" packages/server/src/observe/metrics.ts
   ```
</verification>

<success_criteria>
- [ ] cluster namespace added to MetricsService (app-specific metrics only)
- [ ] ClusterMetrics provides gauges (effect_cluster_*) automatically via Sharding
- [ ] Counters: messagesSent, messagesReceived, redeliveries, errors
- [ ] Histogram: messageLatency with _boundaries.cluster
- [ ] MetricsService.trackCluster static method
- [ ] trackCluster labels errors by type (e.reason)
- [ ] Typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-cluster-foundation/01-03-SUMMARY.md`
</output>
