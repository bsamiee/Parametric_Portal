---
phase: 01-cluster-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/server/src/observe/metrics.ts
autonomous: true

must_haves:
  truths:
    - "Cluster metrics (entity count, runner count, shard count) exported via MetricsService"
    - "ClusterError metrics labeled by error type (MailboxFull, RunnerUnavailable, etc.)"
    - "Metrics follow existing MetricsService.label pattern"
  artifacts:
    - path: "packages/server/src/observe/metrics.ts"
      provides: "Cluster metrics namespace integrated with existing MetricsService"
      contains: "cluster:"
  key_links:
    - from: "packages/server/src/observe/metrics.ts"
      to: "packages/server/src/infra/cluster.ts"
      via: "ClusterService.errorTag for error classification"
      pattern: "cluster\\.errors"
---

<objective>
Add cluster metrics namespace to MetricsService for observability of cluster health.

Purpose: Enable monitoring of cluster state (entities, runners, shards) and error rates by type. Integrates with existing MetricsService.label pattern per STATE.md requirement.

Output: Updated `packages/server/src/observe/metrics.ts` with cluster metrics namespace.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cluster-foundation/01-CONTEXT.md
@.planning/phases/01-cluster-foundation/01-RESEARCH.md
@packages/server/src/observe/metrics.ts
@packages/server/src/infra/cluster.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cluster metrics namespace to MetricsService</name>
  <files>packages/server/src/observe/metrics.ts</files>
  <action>
Update `packages/server/src/observe/metrics.ts` to add cluster-specific metrics.

**Add to _boundaries constant (after existing boundaries):**
```typescript
const _boundaries = {
  http:       [0.001, 0.01, 0.1, 1, 10, 100] as const,
  jobs:       [0.01, 0.1, 1, 10, 100, 1000] as const,
  // ... existing boundaries ...
  cluster:    [0.001, 0.01, 0.05, 0.1, 0.5, 1, 5] as const,  // Message latency (target <100ms)
} as const;
```

**Add cluster namespace to MetricsService effect (inside the Effect.succeed block, after existing namespaces):**

Find the existing `effect: Effect.succeed({` block and add after the `workers:` namespace:

```typescript
cluster: {
  // Gauges for cluster state
  entities: Metric.gauge('cluster_entities_total'),
  runners: Metric.gauge('cluster_runners_total'),
  runnersHealthy: Metric.gauge('cluster_runners_healthy'),
  shards: Metric.gauge('cluster_shards_total'),
  shardsAssigned: Metric.gauge('cluster_shards_assigned'),

  // Counters for operations
  messagesSent: Metric.counter('cluster_messages_sent_total'),
  messagesReceived: Metric.counter('cluster_messages_received_total'),
  redeliveries: Metric.counter('cluster_redeliveries_total'),

  // Histogram for message latency
  messageLatency: Metric.timerWithBoundaries('cluster_message_latency_seconds', _boundaries.cluster),

  // Error counter - labeled by type (MailboxFull, RunnerUnavailable, etc.)
  errors: Metric.counter('cluster_errors_total'),
},
```

**Metrics purpose:**
- `cluster_entities_total`: Current entity count (gauge)
- `cluster_runners_total`: Registered runner count (gauge)
- `cluster_runners_healthy`: Healthy runner count (gauge)
- `cluster_shards_total`: Total shard count (gauge)
- `cluster_shards_assigned`: Assigned shard count (gauge)
- `cluster_messages_sent_total`: Messages sent counter (labels: entity_type)
- `cluster_messages_received_total`: Messages received counter (labels: entity_type)
- `cluster_redeliveries_total`: Message redelivery counter
- `cluster_message_latency_seconds`: Message delivery latency histogram
- `cluster_errors_total`: Error counter (labels: type - MailboxFull, PersistenceError, etc.)

**Labeling pattern:**
Cluster metrics use the existing `MetricsService.label({ type: 'MailboxFull' })` pattern for error type discrimination.
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
Verify cluster namespace exists:
```bash
grep -n "cluster:" packages/server/src/observe/metrics.ts
grep -n "cluster_entities" packages/server/src/observe/metrics.ts
grep -n "cluster_errors" packages/server/src/observe/metrics.ts
```
  </verify>
  <done>
- cluster namespace added to MetricsService effect
- Gauges for entities, runners, shards
- Counters for messages, redeliveries, errors
- Histogram for message latency
- _boundaries.cluster defined for SLA-aligned buckets
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cluster error tracking utility</name>
  <files>packages/server/src/observe/metrics.ts</files>
  <action>
Add a utility method for tracking cluster errors with type labels. This integrates with the existing `MetricsService.trackEffect` pattern.

**Add static method to MetricsService class (after trackStreamProgress):**

```typescript
/** Track cluster operation with error classification */
static readonly trackCluster = <A, E extends { readonly reason: string }, R>(
  effect: Effect.Effect<A, E, R>,
  config: {
    readonly operation: 'send' | 'broadcast' | 'receive';
    readonly entityType: string;
  },
): Effect.Effect<A, E, R | MetricsService> =>
  Effect.gen(function* () {
    const metrics = yield* MetricsService;
    const labels = MetricsService.label({
      entity_type: config.entityType,
      operation: config.operation,
    });
    return yield* effect.pipe(
      Effect.tap(() => config.operation === 'send'
        ? Metric.increment(Metric.taggedWithLabels(metrics.cluster.messagesSent, labels))
        : config.operation === 'receive'
          ? Metric.increment(Metric.taggedWithLabels(metrics.cluster.messagesReceived, labels))
          : Effect.void,
      ),
      Metric.trackDuration(Metric.taggedWithLabels(metrics.cluster.messageLatency, labels)),
      Effect.tapError((e) => {
        const errorLabels = MetricsService.label({
          entity_type: config.entityType,
          type: e.reason,  // ClusterError.reason: 'MailboxFull' | 'RunnerUnavailable' | etc.
        });
        return Metric.increment(Metric.taggedWithLabels(metrics.cluster.errors, errorLabels));
      }),
    );
  }).pipe(Effect.flatten);
```

**Usage pattern** (will be used in cluster.ts):
```typescript
// In ClusterService.send:
MetricsService.trackCluster(
  sharding.send(entity, request),
  { operation: 'send', entityType: 'Cluster' },
)
```

This utility:
- Increments message counters (sent/received based on operation)
- Tracks message latency via histogram
- Increments error counter with type label on failure
- Uses `e.reason` for error classification (works with ClusterError)
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
Verify trackCluster method:
```bash
grep -n "trackCluster" packages/server/src/observe/metrics.ts
```
  </verify>
  <done>
- MetricsService.trackCluster static method added
- Tracks message counts by operation type
- Tracks message latency histogram
- Tracks errors by type (e.reason)
- Uses existing MetricsService.label pattern
  </done>
</task>

</tasks>

<verification>
Overall verification for Plan 03:

1. **Typecheck passes:**
   ```bash
   pnpm exec nx run server:typecheck
   ```

2. **Cluster metrics present:**
   ```bash
   grep -n "cluster:" packages/server/src/observe/metrics.ts
   grep -n "cluster_entities" packages/server/src/observe/metrics.ts
   grep -n "cluster_errors" packages/server/src/observe/metrics.ts
   grep -n "cluster_message_latency" packages/server/src/observe/metrics.ts
   ```

3. **trackCluster utility:**
   ```bash
   grep -n "trackCluster" packages/server/src/observe/metrics.ts
   ```

4. **Boundaries defined:**
   ```bash
   grep -n "_boundaries.cluster" packages/server/src/observe/metrics.ts
   ```
</verification>

<success_criteria>
- [ ] cluster namespace added to MetricsService
- [ ] Gauges: entities, runners, runnersHealthy, shards, shardsAssigned
- [ ] Counters: messagesSent, messagesReceived, redeliveries, errors
- [ ] Histogram: messageLatency with _boundaries.cluster
- [ ] MetricsService.trackCluster static method
- [ ] trackCluster labels errors by type (e.reason)
- [ ] Typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-cluster-foundation/01-03-SUMMARY.md`
</output>
