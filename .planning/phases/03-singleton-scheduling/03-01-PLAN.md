---
phase: 03-singleton-scheduling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/infra/cluster.ts
  - packages/server/src/observe/metrics.ts
autonomous: true

must_haves:
  truths:
    - "State persistence failures are typed and retryable (StateLoadFailed, StatePersistFailed can be retried)"
    - "Singleton execution is observable via duration histogram, execution counter, and heartbeat gauge"
    - "Singleton state survives leader migrations via SQL-backed persistence"
  artifacts:
    - path: "packages/server/src/infra/cluster.ts"
      provides: "SingletonError class, _kvStoreLayers, _CONFIG.singleton"
      contains: "class SingletonError"
    - path: "packages/server/src/observe/metrics.ts"
      provides: "Singleton metrics namespace"
      contains: "singleton:"
  key_links:
    - from: "packages/server/src/infra/cluster.ts"
      to: "@effect/sql"
      via: "SqlClient for KeyValueStore"
      pattern: "SqlClient\\.SqlClient"
---

<objective>
Add SingletonError class, singleton metrics namespace, and SQL-backed KeyValueStore layer.

Purpose: Foundation for stateful singleton factories — error handling, metrics tracking, and persistence layer.
Output: SingletonError with 5 reasons, MetricsService.singleton metrics, _kvStoreLayers IIFE in cluster.ts
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-singleton-scheduling/03-RESEARCH.md
@packages/server/src/infra/cluster.ts
@packages/server/src/observe/metrics.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SingletonError and _CONFIG.singleton to cluster.ts</name>
  <files>packages/server/src/infra/cluster.ts</files>
  <action>
Add SingletonError class after ClusterError in the [ERRORS] section. Use Data.TaggedError pattern (not Schema.TaggedError since these errors do not cross serialization boundaries).

```typescript
// Add import: Data from 'effect' (already imported)
// Add type import: import type { PlatformError } from '@effect/platform';

class SingletonError extends Data.TaggedError('SingletonError')<{
  readonly reason: 'StateLoadFailed' | 'StatePersistFailed' | 'SchemaDecodeFailed' | 'HeartbeatFailed' | 'LeaderHandoffFailed';
  readonly cause?: unknown;
  readonly singletonName: string;
}> {
  static readonly _retryable: ReadonlySet<SingletonError['reason']> = new Set(['StateLoadFailed', 'StatePersistFailed']);
  static readonly isRetryable = (e: SingletonError): boolean => SingletonError._retryable.has(e.reason);
  static readonly from = Match.type<{ reason: SingletonError['reason']; name: string; cause: unknown }>().pipe(
    Match.when({ reason: 'StateLoadFailed' }, ({ name, cause }) => new SingletonError({ reason: 'StateLoadFailed', cause, singletonName: name })),
    Match.when({ reason: 'StatePersistFailed' }, ({ name, cause }) => new SingletonError({ reason: 'StatePersistFailed', cause, singletonName: name })),
    Match.when({ reason: 'SchemaDecodeFailed' }, ({ name, cause }) => new SingletonError({ reason: 'SchemaDecodeFailed', cause, singletonName: name })),
    Match.when({ reason: 'HeartbeatFailed' }, ({ name, cause }) => new SingletonError({ reason: 'HeartbeatFailed', cause, singletonName: name })),
    Match.when({ reason: 'LeaderHandoffFailed' }, ({ name, cause }) => new SingletonError({ reason: 'LeaderHandoffFailed', cause, singletonName: name })),
    Match.exhaustive,
  );
}
```

Add `_CONFIG.singleton` namespace (flat structure matching existing pattern):

```typescript
// Extend existing _CONFIG:
singleton: {
  graceMs: Duration.toMillis(Duration.seconds(60)),
  threshold: 2,
  heartbeatInterval: Duration.seconds(30),
  keyPrefix: 'singleton-state:',
  schemaVersion: 1,
  migrationSlaMs: 10_000,
},
```

Add Match import if not present (check existing imports — Match is used but may need explicit import).

Export SingletonError via namespace and ClusterService.Error.Singleton alias.
  </action>
  <verify>
`grep -n "class SingletonError" packages/server/src/infra/cluster.ts` returns line number.
`grep -n "singleton:" packages/server/src/infra/cluster.ts` shows _CONFIG.singleton exists.
  </verify>
  <done>
SingletonError class with 5 reason variants exists. _CONFIG.singleton namespace defined. Match.exhaustive factory method works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add singleton metrics to MetricsService</name>
  <files>packages/server/src/observe/metrics.ts</files>
  <action>
Add `singleton` namespace to MetricsService effect object (after `search` or alphabetically appropriate position):

```typescript
singleton: {
  duration: Metric.timerWithBoundaries('singleton_duration_seconds', _boundaries.jobs),
  executions: Metric.counter('singleton_executions_total'),
  lastExecution: Metric.gauge('singleton_last_execution'),
  stateErrors: Metric.counter('singleton_state_errors_total'),
},
```

Use `_boundaries.jobs` for duration (same scale as background processing). The `lastExecution` gauge stores Unix timestamp for heartbeat tracking.
  </action>
  <verify>
`grep -n "singleton:" packages/server/src/observe/metrics.ts` shows singleton namespace.
`grep -n "singleton_duration_seconds" packages/server/src/observe/metrics.ts` shows timer metric.
  </verify>
  <done>
MetricsService has singleton namespace with duration histogram, executions counter, lastExecution gauge, and stateErrors counter.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add SQL-backed KeyValueStore layer to cluster.ts</name>
  <files>packages/server/src/infra/cluster.ts</files>
  <action>
Add `_kvStoreLayers` IIFE in [LAYERS] section (after _storageLayers). Uses SqlClient from existing DbClient.layer:

```typescript
// Add imports:
// import { KeyValueStore } from '@effect/platform';
// import { Array as A } from 'effect'; (A is already imported)

const _kvStoreLayers = (() => {
  const sql = (key: string) => SqlClient.SqlClient.pipe(
    Effect.flatMap((client) => client`SELECT value FROM kv_store WHERE key = ${key}`),
    Effect.map(A.head),
    Effect.map(Option.flatMap((r: { value?: string }) => Option.fromNullable(r.value))),
  );
  return Layer.succeed(KeyValueStore.KeyValueStore, KeyValueStore.make({
    get: (key) => sql(key).pipe(Effect.map(Option.getOrNull)),
    set: (key, value) => SqlClient.SqlClient.pipe(
      Effect.flatMap((client) => client`
        INSERT INTO kv_store (key, value, updated_at) VALUES (${key}, ${value}, NOW())
        ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value, updated_at = NOW()
      `),
      Effect.asVoid,
    ),
    remove: (key) => SqlClient.SqlClient.pipe(Effect.flatMap((c) => c`DELETE FROM kv_store WHERE key = ${key}`), Effect.asVoid),
    has: (key) => sql(key).pipe(Effect.map(Option.isSome)),
    isEmpty: SqlClient.SqlClient.pipe(Effect.flatMap((c) => c`SELECT 1 FROM kv_store LIMIT 1`), Effect.map(A.isEmptyArray)),
    size: SqlClient.SqlClient.pipe(Effect.flatMap((c) => c`SELECT COUNT(*)::int as count FROM kv_store`), Effect.map((r: ReadonlyArray<{ count?: number }>) => r[0]?.count ?? 0)),
    clear: SqlClient.SqlClient.pipe(Effect.flatMap((c) => c`DELETE FROM kv_store`), Effect.asVoid),
    modify: (key, f) => sql(key).pipe(
      Effect.map(Option.getOrNull),
      Effect.flatMap((current) => {
        const next = f(current);
        return SqlClient.SqlClient.pipe(
          Effect.flatMap((c) => c`
            INSERT INTO kv_store (key, value, updated_at) VALUES (${key}, ${next}, NOW())
            ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value, updated_at = NOW()
          `),
          Effect.as([current, next] as const),
        );
      }),
    ),
  }));
})();
```

Add `SqlClient` import from `@effect/sql` and `KeyValueStore` import from `@effect/platform`.

NOTE: The `kv_store` table must exist. Add a comment indicating table schema:
```sql
-- Required table: CREATE TABLE kv_store (key TEXT PRIMARY KEY, value TEXT, updated_at TIMESTAMPTZ DEFAULT NOW());
```
  </action>
  <verify>
`grep -n "_kvStoreLayers" packages/server/src/infra/cluster.ts` shows IIFE exists.
`grep -n "KeyValueStore.make" packages/server/src/infra/cluster.ts` shows implementation.
`pnpm exec nx run server:typecheck` passes.
  </verify>
  <done>
SQL-backed KeyValueStore layer exists in cluster.ts. Layer uses SqlClient for persistence. IIFE pattern matches existing _storageLayers.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec nx run server:typecheck` passes with no errors
2. `grep -c "SingletonError" packages/server/src/infra/cluster.ts` returns 3+ occurrences
3. `grep -c "singleton" packages/server/src/observe/metrics.ts` returns 4+ occurrences
4. `grep -c "KeyValueStore" packages/server/src/infra/cluster.ts` returns 2+ occurrences
</verification>

<success_criteria>
- SingletonError class exists with 5 reason variants
- Match.exhaustive factory ensures no unhandled cases
- MetricsService.singleton namespace has 4 metrics
- SQL-backed KeyValueStore layer ready for state persistence
- All typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-singleton-scheduling/03-01-SUMMARY.md`
</output>
