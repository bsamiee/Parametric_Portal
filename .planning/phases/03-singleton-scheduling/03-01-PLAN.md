---
phase: 03-singleton-scheduling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/infra/cluster.ts
  - packages/server/src/observe/metrics.ts
autonomous: true

must_haves:
  truths:
    - "State persistence failures are typed and retryable (StateLoadFailed, StatePersistFailed)"
    - "Singleton execution observable via duration histogram, execution counter, heartbeat gauge"
    - "Singleton state survives leader migrations via SQL-backed persistence"
    - "KeyValueStore.modify is NOT atomic — critical sections require SqlClient.withTransaction"
    - "Metrics are module-level constants to prevent duplicate Prometheus registration"
    - "All time-based logic uses Clock.currentTimeMillis for testability"
  artifacts:
    - path: "packages/server/src/infra/cluster.ts"
      provides: "SingletonError class, _kvStoreLayers, _CONFIG.singleton"
      contains: "class SingletonError"
    - path: "packages/server/src/observe/metrics.ts"
      provides: "Singleton metrics namespace"
      contains: "singleton:"
  key_links:
    - from: "packages/server/src/infra/cluster.ts"
      to: "@effect/sql"
      via: "SqlClient for KeyValueStore"
      pattern: "SqlClient\\.SqlClient"
    - from: "packages/server/src/infra/cluster.ts"
      to: "@effect/platform"
      via: "KeyValueStore interface"
      pattern: "KeyValueStore\\.make"
---

<objective>
Add SingletonError class, singleton metrics namespace, and SQL-backed KeyValueStore layer.

Purpose: Foundation for stateful singleton factories — error handling, metrics tracking, and persistence layer.
Output: SingletonError with 5 reasons, MetricsService.singleton metrics, _kvStoreLayers IIFE in cluster.ts
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-singleton-scheduling/03-RESEARCH.md
@packages/server/src/infra/cluster.ts
@packages/server/src/observe/metrics.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SingletonError and _CONFIG.singleton to cluster.ts</name>
  <files>packages/server/src/infra/cluster.ts</files>
  <action>
Add SingletonError class after ClusterError in the [ERRORS] section. Use Data.TaggedError pattern (not Schema.TaggedError since these errors do not cross serialization boundaries).

**IMPORTS**: Add to existing effect import line:
```typescript
// Existing: import { Boolean as B, Cause, Chunk, Clock, Config, Duration, Effect, Layer, Ref, Schedule, Schema as S } from 'effect';
// Add: Data, HashMap, HashSet, Match, Number, Tuple
// NOTE: Clock already present — used for testable time access (Clock.currentTimeMillis vs Date.now())
// NOTE: HashMap/HashSet from GROUP3 research — O(1) deduplication and gauge caching
import { Boolean as B, Cause, Chunk, Clock, Config, Data, Duration, Effect, HashMap, HashSet, Layer, Match, Number as N, Ref, Schedule, Schema as S, Tuple } from 'effect';
```

**SingletonError** (place after ClusterError, before [LAYERS]):
```typescript
class SingletonError extends Data.TaggedError('SingletonError')<{
  readonly reason: 'StateLoadFailed' | 'StatePersistFailed' | 'SchemaDecodeFailed' | 'HeartbeatFailed' | 'LeaderHandoffFailed';
  readonly cause?: unknown;
  readonly singletonName: string;
}> {
  // Set-based retryable check — O(1) lookup, matches ClusterError._transient pattern
  static readonly _retryable: ReadonlySet<SingletonError['reason']> = new Set(['StateLoadFailed', 'StatePersistFailed']);
  static readonly isRetryable = (e: SingletonError): boolean => SingletonError._retryable.has(e.reason);

  // Static factories — match ClusterError.from* pattern for consistency
  static readonly fromStateLoad = (name: string, cause?: unknown) => new SingletonError({ reason: 'StateLoadFailed', cause, singletonName: name });
  static readonly fromStatePersist = (name: string, cause?: unknown) => new SingletonError({ reason: 'StatePersistFailed', cause, singletonName: name });
  static readonly fromSchemaDecode = (name: string, cause?: unknown) => new SingletonError({ reason: 'SchemaDecodeFailed', cause, singletonName: name });
  static readonly fromHeartbeat = (name: string, cause?: unknown) => new SingletonError({ reason: 'HeartbeatFailed', cause, singletonName: name });
  static readonly fromLeaderHandoff = (name: string, cause?: unknown) => new SingletonError({ reason: 'LeaderHandoffFailed', cause, singletonName: name });

  // Exhaustive factory via Match.type — compile-time guarantee all reasons have factory
  // Use when reason comes from external source (e.g., deserialized error)
  static readonly from = Match.type<{ reason: SingletonError['reason']; name: string; cause?: unknown }>().pipe(
    Match.when({ reason: 'StateLoadFailed' }, ({ name, cause }) => SingletonError.fromStateLoad(name, cause)),
    Match.when({ reason: 'StatePersistFailed' }, ({ name, cause }) => SingletonError.fromStatePersist(name, cause)),
    Match.when({ reason: 'SchemaDecodeFailed' }, ({ name, cause }) => SingletonError.fromSchemaDecode(name, cause)),
    Match.when({ reason: 'HeartbeatFailed' }, ({ name, cause }) => SingletonError.fromHeartbeat(name, cause)),
    Match.when({ reason: 'LeaderHandoffFailed' }, ({ name, cause }) => SingletonError.fromLeaderHandoff(name, cause)),
    Match.exhaustive,
  );
}
```

**_CONFIG.singleton** (add to existing _CONFIG, flat structure):
```typescript
const _CONFIG = {
  cron:   { skipIfOlderThan: Duration.minutes(5) },
  entity: { concurrency: 1, mailboxCapacity: 100, maxIdleTime: Duration.minutes(5) },
  retry:  {
    defect:    { base: Duration.millis(100), factor: 2, maxAttempts: 5 },
    transient: { base: Duration.millis(50),  cap: Duration.seconds(5), maxAttempts: 3 },
  },
  singleton: {
    graceMs: Duration.toMillis(Duration.seconds(60)),
    heartbeatInterval: Duration.seconds(30),
    keyPrefix: 'singleton-state:',
    migrationSlaMs: 10_000,
    schemaVersion: 1,
    // N.clamp ensures threshold stays within bounds — self-documenting validation
    threshold: N.clamp({ minimum: 1, maximum: 5 })(2),
  },
  sla:    { sendTimeout: Duration.millis(100) },
} as const;
```

**Namespace export** (add to ClusterService namespace):
```typescript
namespace ClusterService {
  // ... existing types ...
  export type SingletonError = InstanceType<typeof SingletonError>;
  export type SingletonErrorReason = SingletonError['reason'];
}
```

**Static alias** (add to ClusterService class):
```typescript
static readonly Error = { Cluster: ClusterError, Singleton: SingletonError };
```

NOTE: This changes `ClusterService.Error` from `ClusterError` to `{ Cluster, Singleton }` — update any existing references.
  </action>
  <verify>
`grep -n "class SingletonError" packages/server/src/infra/cluster.ts` returns line number.
`grep -n "singleton:" packages/server/src/infra/cluster.ts` shows _CONFIG.singleton exists.
  </verify>
  <done>
SingletonError class with 5 reason variants and static factories exists. _CONFIG.singleton namespace defined. ClusterService.Error updated to { Cluster, Singleton }.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add singleton metrics to MetricsService</name>
  <files>packages/server/src/observe/metrics.ts</files>
  <action>
Add `singleton` namespace to MetricsService effect object (after `search` or alphabetically appropriate position).

**CRITICAL**: Metrics must be module-level constants to prevent duplicate Prometheus registration. Labels distinguish singletons: `MetricsService.label({ singleton: name })`.

```typescript
singleton: {
  duration: Metric.timerWithBoundaries('singleton_duration_seconds', _boundaries.jobs),
  executions: Metric.counter('singleton_executions_total'),
  lastExecution: Metric.gauge('singleton_last_execution_timestamp'),
  stateErrors: Metric.counter('singleton_state_errors_total'),
  stateOperations: Metric.counter('singleton_state_operations_total'),
},
```

**Metric Purposes**:
- `duration` — Execution time histogram using `_boundaries.jobs` (same scale as background processing)
- `executions` — Counter of total singleton executions (success + failure)
- `lastExecution` — Unix timestamp gauge for heartbeat/staleness tracking (gauge value = Clock.currentTimeMillis result)
- `stateErrors` — Counter for state persistence failures (labeled by reason)
- `stateOperations` — Counter for state load/persist operations (labeled by op: 'load' | 'persist')

**Usage Pattern** (for Plan 02 reference):
```typescript
// Update heartbeat gauge — use Effect-native time via Clock
Clock.currentTimeMillis.pipe(
  Effect.tap((ts) => Metric.set(metrics.singleton.lastExecution, ts)),
)

// Track state errors by reason
Effect.tapError((e: SingletonError) =>
  MetricsService.inc(
    metrics.singleton.stateErrors,
    MetricsService.label({ reason: e.reason, singleton: name })
  )
)
```
  </action>
  <verify>
`grep -n "singleton:" packages/server/src/observe/metrics.ts` shows singleton namespace.
`grep -n "singleton_duration_seconds" packages/server/src/observe/metrics.ts` shows timer metric.
`grep -n "singleton_last_execution_timestamp" packages/server/src/observe/metrics.ts` shows gauge metric.
  </verify>
  <done>
MetricsService has singleton namespace with 5 metrics: duration histogram, executions counter, lastExecution gauge, stateErrors counter, stateOperations counter.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add SQL-backed KeyValueStore layer to cluster.ts</name>
  <files>packages/server/src/infra/cluster.ts</files>
  <action>
Add `_kvStoreLayers` IIFE in [LAYERS] section (after _storageLayers). Uses SqlClient from existing DbClient.layer.

**IMPORTS** (consolidate with Task 1 imports):
```typescript
// Add to @effect/platform import:
import { FetchHttpClient, KeyValueStore, Socket } from '@effect/platform';

// Existing SqlClient import (verify present):
import { SqlClient } from '@effect/sql';

// Consolidated effect import (Array as A, Option, Tuple added to Task 1 imports):
// NOTE: Full import list from research synthesis — HashMap/HashSet for O(1) ops, Tuple for typed pairs
import { Array as A, Boolean as B, Cause, Chunk, Clock, Config, Data, Duration, Effect, HashMap, HashSet, Layer, Match, Number as N, Option, Ref, Schedule, Schema as S, Tuple } from 'effect';
```

**KeyValueStore IIFE** (place after _storageLayers, before _healthLayer):
```typescript
// SQL-backed KeyValueStore for singleton state persistence
// NOTE: modify() is NOT atomic across concurrent executions — wrap critical sections in SqlClient.withTransaction
// Required table: CREATE TABLE kv_store (key TEXT PRIMARY KEY, value TEXT NOT NULL, updated_at TIMESTAMPTZ DEFAULT NOW());
const _kvStoreLayers = (() => {
  const _get = (key: string) => Effect.flatMap(SqlClient.SqlClient, (sql) =>
    sql<{ value: string }>`SELECT value FROM kv_store WHERE key = ${key}`.pipe(
      Effect.map(A.head),
      Effect.map(Option.map((r) => r.value)),
    ),
  );
  return Layer.succeed(KeyValueStore.KeyValueStore, KeyValueStore.make({
    get: (key) => _get(key).pipe(Effect.map(Option.getOrNull)),
    set: (key, value) => Effect.flatMap(SqlClient.SqlClient, (sql) =>
      sql`INSERT INTO kv_store (key, value, updated_at) VALUES (${key}, ${value}, NOW())
          ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value, updated_at = NOW()`.pipe(Effect.asVoid),
    ),
    remove: (key) => Effect.flatMap(SqlClient.SqlClient, (sql) =>
      sql`DELETE FROM kv_store WHERE key = ${key}`.pipe(Effect.asVoid),
    ),
    has: (key) => _get(key).pipe(Effect.map(Option.isSome)),
    isEmpty: Effect.flatMap(SqlClient.SqlClient, (sql) =>
      sql`SELECT 1 FROM kv_store LIMIT 1`.pipe(Effect.map(A.isEmptyArray)),
    ),
    size: Effect.flatMap(SqlClient.SqlClient, (sql) =>
      sql<{ count: number }>`SELECT COUNT(*)::int AS count FROM kv_store`.pipe(
        Effect.map((r) => r[0]?.count ?? 0),
      ),
    ),
    clear: Effect.flatMap(SqlClient.SqlClient, (sql) =>
      sql`DELETE FROM kv_store`.pipe(Effect.asVoid),
    ),
    modify: (key, f) => _get(key).pipe(
      Effect.map(Option.getOrNull),
      Effect.flatMap((current) => {
        const next = f(current);
        return Effect.flatMap(SqlClient.SqlClient, (sql) =>
          sql`INSERT INTO kv_store (key, value, updated_at) VALUES (${key}, ${next}, NOW())
              ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value, updated_at = NOW()`.pipe(
            // GROUP3 research: Use Tuple.make for typed pairs instead of raw const assertion
            Effect.as(Tuple.make(current, next)),
          ),
        );
      }),
    ),
  }));
})();
```

**Pattern Notes**:
- Uses `Effect.flatMap(SqlClient.SqlClient, (sql) => ...)` pattern (cleaner than `.pipe(Effect.flatMap(...))` chain)
- Typed query results: `sql<{ value: string }>` and `sql<{ count: number }>` for type inference
- UPSERT via `ON CONFLICT ... DO UPDATE` for idempotent writes
- `_get` helper factored out for reuse across `get`, `has`, `modify`
- Layer provides KeyValueStore.KeyValueStore tag — consumers use `KeyValueStore.forSchema(schema)` for typed access
- `Tuple.make(current, next)` provides typed pair with `Tuple.getFirst`/`Tuple.getSecond` accessors

**Database Migration** (add to database package migrations):
```sql
-- Migration: 20260129_add_kv_store.sql
CREATE TABLE IF NOT EXISTS kv_store (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX idx_kv_store_updated_at ON kv_store (updated_at);
```
  </action>
  <verify>
`grep -n "_kvStoreLayers" packages/server/src/infra/cluster.ts` shows IIFE exists.
`grep -n "KeyValueStore.make" packages/server/src/infra/cluster.ts` shows implementation.
`grep -n "SqlClient.SqlClient" packages/server/src/infra/cluster.ts` shows SqlClient usage.
`pnpm exec nx run server:typecheck` passes.
  </verify>
  <done>
SQL-backed KeyValueStore layer exists in cluster.ts. Layer uses SqlClient for persistence. IIFE pattern matches existing _storageLayers. Typed SQL queries with proper Option handling.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec nx run server:typecheck` passes with no errors
2. `grep -c "SingletonError" packages/server/src/infra/cluster.ts` returns 5+ occurrences (class + factories)
3. `grep -c "singleton" packages/server/src/observe/metrics.ts` returns 5+ occurrences (namespace + 5 metrics)
4. `grep -c "KeyValueStore" packages/server/src/infra/cluster.ts` returns 3+ occurrences (import + make + tag)
5. `grep -c "SqlClient.SqlClient" packages/server/src/infra/cluster.ts` returns 5+ occurrences (KV operations)
</verification>

<success_criteria>
- SingletonError class exists with 5 reason variants and static factory methods (fromStateLoad, fromStatePersist, etc.)
- SingletonError._retryable Set enables O(1) retryable check (matches ClusterError._transient pattern)
- SingletonError.from exhaustive factory via Match.type + Match.exhaustive ensures compile-time coverage
- MetricsService.singleton namespace has 5 metrics: duration, executions, lastExecution, stateErrors, stateOperations
- SQL-backed KeyValueStore layer uses typed queries (`sql<{ value: string }>`) and proper Option handling
- _CONFIG.singleton namespace uses flat structure with N.clamp for threshold bounds validation
- ClusterService.Error updated to `{ Cluster, Singleton }` object for namespaced error access
- All imports consolidated: Data, HashMap, HashSet, Match, Number as N, Option, Array as A, Tuple added to effect import
- Tuple.make used for modify return type (typed pairs with accessor methods)
- All typecheck passes
</success_criteria>


<output>
After completion, create `.planning/phases/03-singleton-scheduling/03-01-SUMMARY.md`
</output>
