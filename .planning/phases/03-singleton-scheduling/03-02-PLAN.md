---
phase: 03-singleton-scheduling
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/server/src/infra/cluster.ts
autonomous: true

must_haves:
  truths:
    - "ClusterService.singleton() accepts optional state schema with typed persistence"
    - "Singleton factories auto-wrap with withinCluster({ isLeader: true })"
    - "Lifecycle hooks onBecomeLeader and onLoseLeadership execute at appropriate times"
    - "Heartbeat gauge updated after each singleton execution via Clock.currentTimeMillis"
  artifacts:
    - path: "packages/server/src/infra/cluster.ts"
      provides: "Extended singleton and cron factory methods"
      contains: "onBecomeLeader"
  key_links:
    - from: "packages/server/src/infra/cluster.ts"
      to: "packages/server/src/context.ts"
      via: "Context.Request.withinCluster"
      pattern: "withinCluster.*isLeader"
    - from: "packages/server/src/infra/cluster.ts"
      to: "packages/server/src/observe/metrics.ts"
      via: "MetricsService.trackEffect"
      pattern: "MetricsService\\.trackEffect"
---

<objective>
Extend ClusterService.singleton() and ClusterService.cron() factories with state persistence, lifecycle hooks, and automatic withinCluster context wrapping.

Purpose: Enable stateful singletons that persist across leader migrations with proper observability.
Output: Enhanced singleton/cron factories with state schema, lifecycle hooks, MetricsService.trackEffect integration.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-singleton-scheduling/03-RESEARCH.md
@.planning/phases/03-singleton-scheduling/03-01-SUMMARY.md
@packages/server/src/infra/cluster.ts
@packages/server/src/context.ts
@packages/server/src/observe/metrics.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ClusterService.singleton() factory with state and lifecycle hooks</name>
  <files>packages/server/src/infra/cluster.ts</files>
  <action>
Replace existing `ClusterService.singleton` static method with enhanced version. Add Context import for withinCluster:

```typescript
// Add import at top:
// import { Context } from '../context.ts';

static readonly singleton = <State, E, R>(
  name: string,
  run: Effect.Effect<void, E, R>,
  options?: {
    readonly shardGroup?: string;
    readonly state?: { readonly schema: S.Schema<State, unknown>; readonly initial: State };
    readonly onBecomeLeader?: Effect.Effect<void, never, R>;
    readonly onLoseLeadership?: Effect.Effect<void, never, R>;
  },
) => {
  // Lifecycle: setup on entry, cleanup on scope close
  const withLifecycle = Effect.gen(function* () {
    yield* options?.onBecomeLeader ?? Effect.void;
    yield* Effect.addFinalizer(() => options?.onLoseLeadership ?? Effect.void);
  });
  // State: load from KV store if schema provided, persist after each run
  const withState = Effect.if(options?.state !== undefined, {
    onTrue: () => KeyValueStore.KeyValueStore.pipe(
      Effect.andThen((kv) => kv.forSchema(options!.state!.schema)),
      Effect.andThen((store) => store.get(name).pipe(
        Effect.flatMap(S.decodeUnknown(options!.state!.schema)),
        Effect.orElseSucceed(() => options!.state!.initial),
        Effect.andThen((state) => run.pipe(Effect.tap(() => store.set(name, state)))),
      )),
    ),
    onFalse: () => run,
  });
  return Singleton.make(
    name,
    Effect.gen(function* () {
      const metrics = yield* MetricsService;
      yield* Effect.annotateLogsScoped({ 'service.name': `singleton.${name}` });
      // Update heartbeat gauge after execution via Clock.currentTimeMillis (testable)
      const updateHeartbeat = Clock.currentTimeMillis.pipe(
        Effect.flatMap((ts) => Metric.set(metrics.singleton.lastExecution, ts)),
      );
      yield* withLifecycle;
      yield* Context.Request.withinCluster({ isLeader: true })(
        Telemetry.span(withState, `singleton.${name}`, { metrics: false }).pipe(
          MetricsService.trackEffect({
            duration: metrics.singleton.duration,
            errors: metrics.errors,
            labels: MetricsService.label({ singleton: name }),
          }),
          Effect.tap(() => updateHeartbeat),
          Effect.tap(() => Metric.increment(metrics.singleton.executions)),
        ),
      );
      yield* Effect.never;  // Keep singleton alive
    }),
    { shardGroup: options?.shardGroup },
  ).pipe(Layer.provide(_clusterLayer), Layer.provide(_kvStoreLayers));
};
```

Key changes from existing:
1. Add `options.state` for typed state persistence via KeyValueStore
2. Add `options.onBecomeLeader` and `options.onLoseLeadership` lifecycle hooks
3. Wrap with `Context.Request.withinCluster({ isLeader: true })` for cluster context
4. Use `MetricsService.trackEffect` instead of bare `Telemetry.span`
5. Update heartbeat gauge after each execution
6. Increment executions counter
7. Provide `_kvStoreLayers` for state persistence
8. End with `Effect.never` to keep singleton alive

Add Metric import from effect if not present.
  </action>
  <verify>
`grep -n "onBecomeLeader" packages/server/src/infra/cluster.ts` shows option exists.
`grep -n "withinCluster.*isLeader" packages/server/src/infra/cluster.ts` shows context wrapping.
`grep -n "Effect.never" packages/server/src/infra/cluster.ts` shows singleton stays alive.
  </verify>
  <done>
ClusterService.singleton() accepts state schema, lifecycle hooks, and auto-wraps with withinCluster({ isLeader: true }).
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend ClusterService.cron() factory with MetricsService.trackEffect</name>
  <files>packages/server/src/infra/cluster.ts</files>
  <action>
Replace existing `ClusterService.cron` static method with enhanced version:

```typescript
static readonly cron = <E, R>(config: {
  readonly name: string;
  readonly cron: Parameters<typeof ClusterCron.make>[0]['cron'];
  readonly execute: Effect.Effect<void, E, R>;
  readonly shardGroup?: string;
  readonly skipIfOlderThan?: Duration.DurationInput;
}) =>
  ClusterCron.make({
    cron: config.cron,
    execute: Effect.gen(function* () {
      const metrics = yield* MetricsService;
      yield* Effect.annotateLogsScoped({ 'service.name': `cron.${config.name}` });
      // Update heartbeat gauge after execution (same pattern as singleton)
      const updateHeartbeat = Clock.currentTimeMillis.pipe(
        Effect.flatMap((ts) => Metric.set(metrics.singleton.lastExecution, ts)),
      );
      yield* Context.Request.withinCluster({ isLeader: true })(
        Telemetry.span(config.execute, `cron.${config.name}`, { metrics: false }).pipe(
          MetricsService.trackEffect({
            duration: metrics.singleton.duration,
            errors: metrics.errors,
            labels: MetricsService.label({ singleton: config.name, type: 'cron' }),
          }),
          Effect.tap(() => updateHeartbeat),
          Effect.tap(() => Metric.increment(metrics.singleton.executions)),
        ),
      );
    }),
    name: config.name,
    shardGroup: config.shardGroup,
    skipIfOlderThan: config.skipIfOlderThan ?? _CONFIG.cron.skipIfOlderThan,
  }).pipe(Layer.provide(_clusterLayer));
```

Key changes from existing:
1. Wrap with `Context.Request.withinCluster({ isLeader: true })` for cluster context
2. Use `MetricsService.trackEffect` instead of bare `Telemetry.span`
3. Update heartbeat gauge after execution
4. Increment executions counter
5. Add `type: 'cron'` label to distinguish from singleton metrics
  </action>
  <verify>
`grep -n "type: 'cron'" packages/server/src/infra/cluster.ts` shows cron label.
`grep -n "skipIfOlderThan" packages/server/src/infra/cluster.ts` shows config option.
  </verify>
  <done>
ClusterService.cron() uses MetricsService.trackEffect, withinCluster context, and heartbeat updates.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update ClusterService namespace with SingletonError export</name>
  <files>packages/server/src/infra/cluster.ts</files>
  <action>
Update ClusterService namespace and static exports to include SingletonError:

```typescript
// Add to ClusterService class statics (after existing Error):
static readonly SingletonError = SingletonError;

// Update namespace to include SingletonError types:
namespace ClusterService {
  // ... existing types ...
  export type SingletonError = InstanceType<typeof SingletonError>;
  export type SingletonErrorReason = SingletonError['reason'];
}
```

This allows consumers to access `ClusterService.SingletonError` and `ClusterService.SingletonErrorReason` types.
  </action>
  <verify>
`grep -n "SingletonError" packages/server/src/infra/cluster.ts` shows class and namespace export.
`pnpm exec nx run server:typecheck` passes.
  </verify>
  <done>
ClusterService exports SingletonError via static property and namespace types.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec nx run server:typecheck` passes with no errors
2. `grep -c "withinCluster" packages/server/src/infra/cluster.ts` returns 2+ occurrences (singleton + cron)
3. `grep -c "MetricsService.trackEffect" packages/server/src/infra/cluster.ts` returns 2+ occurrences
4. `grep -c "onBecomeLeader" packages/server/src/infra/cluster.ts` returns 1+ occurrences
</verification>

<success_criteria>
- ClusterService.singleton() accepts optional state schema with typed persistence
- Lifecycle hooks (onBecomeLeader, onLoseLeadership) work correctly
- Both factories auto-wrap with withinCluster({ isLeader: true })
- MetricsService.trackEffect used for duration/error tracking
- Heartbeat gauge updated after each execution
- Typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-singleton-scheduling/03-02-SUMMARY.md`
</output>
