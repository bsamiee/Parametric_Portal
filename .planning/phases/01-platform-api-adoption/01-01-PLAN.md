---
phase: 01-platform-api-adoption
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/platform/cache.ts
autonomous: true

must_haves:
  truths:
    - "CacheService.get() returns cached value without consumer specifying namespace"
    - "CacheService auto-scopes keys by tenantId + userId from FiberRef context"
    - "Cache hits/misses/evictions tracked via MetricsService automatically"
    - "L1 memory cache fronts L2 Redis with automatic tiering"
    - "Redis pub/sub invalidation broadcasts to all server instances"
    - "Rate limiting is integrated — preset-based consume without separate RateLimit.apply"
    - "CacheService.redis exposes Redis client for specialized services"
  artifacts:
    - path: "packages/server/src/platform/cache.ts"
      provides: "CacheService Effect.Service class with L1/L2 architecture"
      exports: ["CacheService"]
  key_links:
    - from: "CacheService"
      to: "Context.Request"
      via: "FiberRef.get for tenantId/session"
      pattern: "Context\\.Request\\.(tenantId|session)"
    - from: "CacheService"
      to: "MetricsService"
      via: "Effect.serviceOption for metric emission"
      pattern: "Effect\\.serviceOption\\(MetricsService\\)"
---

<objective>
Create CacheService as a proper Effect.Service class following the MetricsService polymorphic pattern.

Purpose: Replace loose http/cache.ts wrapper with a dense, intelligent service that provides L1/L2 caching with auto-scope from FiberRef context, integrated rate limiting, and cross-instance invalidation via Redis pub/sub.

Output: Single CacheService class at packages/server/src/platform/cache.ts with static methods for get, invalidate, health, rateLimit, and redis client access.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-platform-api-adoption/01-CONTEXT.md
@.planning/phases/01-platform-api-adoption/01-RESEARCH.md
@packages/server/src/observe/metrics.ts
@packages/server/src/utils/circuit.ts
@packages/server/src/context.ts
@packages/server/src/http/cache.ts
@packages/server/src/security/rate-limit.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CacheService with L1/L2 architecture</name>
  <files>packages/server/src/platform/cache.ts</files>
  <action>
Create CacheService following the MetricsService polymorphic pattern exactly. This is a DENSE service — all logic internalized via static methods.

**Structure (follow MetricsService file organization):**
```
// --- [CONSTANTS] -----------------------------------------------------------------
// --- [ERRORS] --------------------------------------------------------------------
// --- [SERVICES] ------------------------------------------------------------------
// --- [EXPORT] --------------------------------------------------------------------
```

**Service implementation:**

1. **Effect.Service class with scoped effect** — uses `scoped:` because it manages Redis connections:
   ```typescript
   class CacheService extends Effect.Service<CacheService>()("server/CacheService", {
     scoped: Effect.gen(function* () {
       // Setup Redis connections (pub and sub must be separate)
       // Setup @effect/experimental/PersistedCache for L1/L2
       // Setup pub/sub listener for cross-instance invalidation
       // Return internal state
     }),
   }) { /* static methods */ }
   ```

2. **Internal state shape** — NOT exposed to consumers:
   - `_pub`: ioredis client for commands + publishing
   - `_sub`: ioredis client for subscribing (must be separate)
   - `_caches`: Map of domain -> PersistedCache instance
   - `_rateLimiter`: RateLimiter from @effect/experimental

3. **Constants section:**
   ```typescript
   const _config = {
     defaults: { capacity: 1000, ttl: Duration.minutes(5), inMemoryTTL: 10_000 },
     pubsub: { channel: "cache:invalidate" },
     redis: { /* read from env */ },
   } as const;

   const _rateLimitPresets = {
     api: { algorithm: "token-bucket", limit: 100, tokens: 1, window: Duration.minutes(1) },
     auth: { algorithm: "fixed-window", limit: 5, tokens: 1, window: Duration.minutes(15) },
     mfa: { algorithm: "fixed-window", limit: 5, tokens: 1, window: Duration.minutes(15) },
     mutation: { algorithm: "token-bucket", limit: 100, tokens: 5, window: Duration.minutes(1) },
   } as const;
   ```

4. **Static methods (polymorphic API):**

   a. `CacheService.get(domain, lookup)` — Returns a curried function `(key) => Effect<Option<V>>`:
      - Reads tenantId from `Context.Request.tenantId`
      - Reads session from `Context.Request.session` (optional)
      - Builds scoped key: `${tenantId}:${userId}:${domain}:${key}` or `${tenantId}:${domain}:${key}`
      - Uses PersistedCache for L1/L2 lookup with lookup callback
      - Wraps lookup with Resilience.wrap internally (timeout, retry)
      - Emits cache hit/miss metrics via MetricsService
      - Returns Option.some(value) or Option.none() on failure

   b. `CacheService.invalidate(domain, key)` — Broadcasts invalidation:
      - Reads tenantId from context
      - Publishes to Redis channel: `{ domain, key, tenantId }`
      - All instances receive message and clear L1 cache

   c. `CacheService.health()` — Returns `{ l1: boolean, l2: boolean }`:
      - L1 always true (memory)
      - L2 pings Redis, returns true/false

   d. `CacheService.rateLimit(preset)` — Returns Effect that consumes rate limit:
      - Uses integrated @effect/experimental/RateLimiter
      - Reads IP from Context.Request.ipAddress
      - Returns result or fails with RateLimitError
      - NO separate RateLimit.apply needed by consumers

   e. `CacheService.redis` — Exposes Redis client for specialized services:
      - Returns `Effect.map(CacheService, s => s._pub)`
      - Used by totp-replay.ts for direct store access

**Key patterns from MetricsService to follow:**
- Single polymorphic function per concern (like MetricsService.label)
- Static methods that yield* CacheService internally
- Effect.serviceOption(MetricsService) for optional metric emission
- Derive types from schema, not separate declarations

**Key patterns from circuit.ts to follow:**
- const+namespace merge for CacheService export
- Namespace contains Config and Error types
- Registry pattern for cache instances (_caches Map)

**Anti-patterns to AVOID:**
- NO loose const exports (wrap, make, etc.)
- NO consumer-facing namespace parameter
- NO configurable resilience per call
- NO more than 1 internal helper function
- NO type exports that expose internal shapes

**Redis connection setup:**
- Use ioredis directly (already in catalog)
- Read config from environment via Effect.Config
- Separate connections for pub/sub (ioredis requirement)
- Graceful degradation: warn if Redis unavailable, continue with memory-only

**Rate limiting integration:**
- Use @effect/experimental/RateLimiter with Redis store
- Share Redis connection with cache (via _pub client)
- Presets match existing rate-limit.ts: api, auth, mfa, mutation
- Return structured result, not just boolean
  </action>
  <verify>
- File exists at packages/server/src/platform/cache.ts
- File has exactly 4 sections: CONSTANTS, ERRORS, SERVICES, EXPORT
- CacheService class extends Effect.Service
- Static methods: get, invalidate, health, rateLimit, redis
- No loose const/function exports outside namespace
- Maximum 1 helper function
- Typecheck: `pnpm exec nx run server:typecheck`
  </verify>
  <done>
CacheService is a proper Effect.Service class with L1/L2 architecture, auto-scope from FiberRef, integrated rate limiting, and Redis pub/sub for cross-instance invalidation. Follows MetricsService polymorphic pattern exactly.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec nx run server:typecheck` passes
2. CacheService class exists with static methods: get, invalidate, health, rateLimit, redis
3. File structure matches MetricsService: CONSTANTS, SERVICES, EXPORT sections
4. No loose const/function exports — all logic inside class
5. Auto-scope pattern: Context.Request.tenantId and Context.Request.session used internally
6. Metric emission: Effect.serviceOption(MetricsService) pattern for cache hits/misses
7. Rate limit presets: api, auth, mfa, mutation available via CacheService.rateLimit
</verification>

<success_criteria>
- CacheService.get() can be called without namespace parameter
- CacheService auto-derives scope from FiberRef context
- L1/L2 architecture via @effect/experimental/PersistedCache
- Redis pub/sub for invalidation (separate sub connection)
- Rate limiting integrated via static method
- MetricsService integration for observability
- Code follows polymorphic unity — dense service, no helper spam
</success_criteria>

<output>
After completion, create `.planning/phases/01-platform-api-adoption/01-01-SUMMARY.md`
</output>
