---
phase: 01-platform-api-adoption
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/http/resilience.ts
autonomous: true

must_haves:
  truths:
    - "Effect pipelines can apply retry with exponential backoff and jitter"
    - "Effect pipelines can apply timeout with configurable duration"
    - "Circuit breaker state changes emit metrics via MetricsService"
    - "Resilience wrappers compose cleanly with Effect.gen and pipe"
  artifacts:
    - path: "packages/server/src/http/resilience.ts"
      provides: "Unified resilience primitives: retry, timeout, circuit, fallback"
      exports: ["Resilience"]
      min_lines: 100
  key_links:
    - from: "packages/server/src/http/resilience.ts"
      to: "packages/server/src/observe/metrics.ts"
      via: "MetricsService import"
      pattern: "import.*MetricsService"
    - from: "packages/server/src/http/resilience.ts"
      to: "cockatiel"
      via: "CircuitBreakerPolicy integration"
      pattern: "circuitBreaker|CircuitBreaker"
---

<objective>
Build unified resilience module with retry, timeout, circuit breaker, and fallback composition.

Purpose: Foundation layer for all I/O operations requiring resilience. Stream and cache modules depend on these patterns. Replaces scattered retry/timeout logic with composable Effect-native primitives while keeping cockatiel for proven circuit breaker state machine.

Output: `packages/server/src/http/resilience.ts` following metrics.ts polymorphic pattern
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-platform-api-adoption/01-RESEARCH.md

Reference patterns:
@packages/server/src/observe/metrics.ts (polymorphic service pattern)
@packages/server/src/security/circuit.ts (existing circuit implementation to consolidate)
@packages/server/src/context.ts (Context.Request.config.oauth.retry for existing schedule)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resilience module with Effect-native primitives</name>
  <files>packages/server/src/http/resilience.ts</files>
  <action>
Create `packages/server/src/http/resilience.ts` following the metrics.ts polymorphic pattern:

**File Structure:**
1. [CONSTANTS] - Default schedules, timeout durations
2. [SCHEMA] - Configuration schemas if needed
3. [FUNCTIONS] - Pure helper functions
4. [SERVICES] - ResilienceService class extending Effect.Service
5. [EXPORT] - Named export only

**Core Primitives to Implement:**

1. **Retry Schedules** - Pre-built composable schedules:
   ```typescript
   // Default: exponential(100ms, 2x) + jitter + max 3 retries + max 10s total
   const defaultRetry = Schedule.exponential(Duration.millis(100), 2).pipe(
     Schedule.jittered,
     Schedule.intersect(Schedule.recurs(3)),
     Schedule.upTo(Duration.seconds(10))
   )
   // Fast: for rate limit retries
   // Slow: for external API retries (oauth-style)
   ```

2. **Timeout Wrapper** - Composable timeout with typed error:
   ```typescript
   const withTimeout = <A, E, R>(
     effect: Effect.Effect<A, E, R>,
     duration: Duration.Duration
   ): Effect.Effect<A, E | TimeoutError, R>
   ```

3. **Circuit Breaker Integration** - Keep cockatiel, wrap for Effect:
   - Reuse existing Circuit.make pattern from circuit.ts
   - Add static helper: `Resilience.circuit(name, config)`
   - Emit metrics on state changes via MetricsService

4. **Fallback Composition** - Clean fallback API:
   ```typescript
   const withFallback = <A, E, R, A2>(
     effect: Effect.Effect<A, E, R>,
     fallback: Effect.Effect<A2, never, R>
   ): Effect.Effect<A | A2, never, R>
   ```

5. **Unified Wrapper** - Single function for common case:
   ```typescript
   const withResilience = <A, E, R>(
     effect: Effect.Effect<A, E, R>,
     config?: {
       timeout?: Duration.Duration
       retry?: Schedule.Schedule<unknown, E, never>
       circuit?: string // circuit breaker name
       fallback?: Effect.Effect<A, never, R>
     }
   ): Effect.Effect<A, E, R>
   ```

**Key Constraints:**
- Use Effect.retry, Effect.timeout, Effect.catchTag - NO async/await
- Import Schedule, Duration, Effect from 'effect' (no barrel)
- Keep cockatiel for CircuitBreakerPolicy (proven state machine)
- All resilience operations must be traceable (Effect spans)
- Follow CLAUDE.md section separators exactly

**What NOT to do:**
- Do NOT wrap cockatiel in unnecessary abstraction layers
- Do NOT create separate error types - use existing HttpError or Effect built-ins
- Do NOT hand-roll retry delay calculations
  </action>
  <verify>
1. File exists at packages/server/src/http/resilience.ts
2. TypeScript compiles: `pnpm exec nx run server:typecheck`
3. Exports Resilience namespace with: defaultRetry, fastRetry, slowRetry, withTimeout, withFallback, withResilience, circuit
  </verify>
  <done>
Resilience module provides composable primitives for retry, timeout, circuit breaker, and fallback. All use Effect-native patterns with cockatiel for circuit state machine.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add resilience metrics integration</name>
  <files>packages/server/src/http/resilience.ts</files>
  <action>
Extend the resilience module with metrics integration:

1. **Circuit State Metrics** - On state change:
   - Increment `circuit_state_changes_total` with labels: circuit name, from state, to state
   - Use existing MetricsService.label pattern

2. **Retry Metrics** - Track retry attempts:
   - Add counter `resilience_retries_total` with labels: operation, attempt
   - Use Schedule.tapOutput to emit on each retry

3. **Timeout Metrics** - Track timeouts:
   - Add counter `resilience_timeouts_total` with labels: operation
   - Emit on TimeoutException catch

4. **Fallback Metrics** - Track fallback usage:
   - Add counter `resilience_fallbacks_total` with labels: operation, reason
   - Emit when fallback path taken

**Integration Pattern:**
```typescript
// Follow metrics.ts pattern - service access via Effect.gen
const withResilience = <A, E, R>(...) =>
  Effect.gen(function* () {
    const metrics = yield* Effect.serviceOption(MetricsService)
    // ... resilience logic with metric emission
  })
```

**Key Constraint:** Metrics are OPTIONAL - if MetricsService not in context, resilience still works. Use Effect.serviceOption, not Effect.service.
  </action>
  <verify>
1. TypeScript compiles: `pnpm exec nx run server:typecheck`
2. MetricsService import present
3. Metric counters defined for retries, timeouts, fallbacks
  </verify>
  <done>
Resilience module emits metrics for circuit state changes, retry attempts, timeouts, and fallback usage. Metrics are optional - module works without MetricsService in context.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `pnpm exec nx run server:typecheck`
2. File structure follows CLAUDE.md section separators
3. Resilience namespace exports all required primitives
4. Circuit breaker integration preserves cockatiel behavior from security/circuit.ts
5. Metrics integrate with existing MetricsService pattern
</verification>

<success_criteria>
- packages/server/src/http/resilience.ts exists with ~150-200 LOC
- TypeScript compiles without errors
- Exports: Resilience.withRetry, Resilience.withTimeout, Resilience.withFallback, Resilience.withResilience, Resilience.circuit
- Pre-built schedules: Resilience.defaultRetry, Resilience.fastRetry, Resilience.slowRetry
- Metrics counters defined for resilience operations
- Ready for stream.ts and cache.ts to import
</success_criteria>

<output>
After completion, create `.planning/phases/01-platform-api-adoption/01-01-SUMMARY.md`
</output>
