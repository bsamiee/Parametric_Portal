---
phase: 01-platform-api-adoption
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/platform/cache.ts
autonomous: true

must_haves:
  polymorphic_unity:
    max_helpers: 1
    verify: "grep -c '^const _[a-z].*= (' packages/server/src/platform/cache.ts | awk '$1 <= 1'"
  truths:
    - "CacheService.get() returns cached value without consumer specifying namespace"
    - "CacheService auto-scopes keys by tenantId + userId from FiberRef context"
    - "Cache hits/misses/evictions tracked via MetricsService automatically"
    - "L1 memory cache fronts L2 Redis with automatic tiering"
    - "Redis pub/sub invalidation broadcasts to all server instances"
    - "Rate limiting is integrated — preset-based consume without separate RateLimit.apply"
    - "CacheService.redis exposes Redis client for specialized services"
  artifacts:
    - path: "packages/server/src/platform/cache.ts"
      provides: "CacheService Effect.Service class with L1/L2 architecture"
      exports: ["CacheService"]
  key_links:
    - from: "CacheService"
      to: "Context.Request"
      via: "FiberRef.get for tenantId/session"
      pattern: "Context\\.Request\\.(tenantId|session)"
    - from: "CacheService"
      to: "MetricsService"
      via: "Effect.serviceOption for metric emission"
      pattern: "Effect\\.serviceOption\\(MetricsService\\)"
---

<objective>
Create CacheService as a proper Effect.Service class following the MetricsService polymorphic pattern.

Purpose: Replace loose http/cache.ts wrapper with a dense, intelligent service that provides L1/L2 caching with auto-scope from FiberRef context, integrated rate limiting, and cross-instance invalidation via Redis pub/sub.

Output: Single CacheService class at packages/server/src/platform/cache.ts with static methods for get, invalidate, health, rateLimit, and redis client access.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-platform-api-adoption/01-CONTEXT.md
@.planning/phases/01-platform-api-adoption/01-RESEARCH.md
@packages/server/src/observe/metrics.ts
@packages/server/src/utils/circuit.ts
@packages/server/src/context.ts
@packages/server/src/http/cache.ts
@packages/server/src/security/rate-limit.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CacheService core with L1/L2 architecture</name>
  <files>packages/server/src/platform/cache.ts</files>
  <action>
**PREREQUISITE:** Create platform directory first:
```bash
mkdir -p packages/server/src/platform
```

Create CacheService following the MetricsService polymorphic pattern exactly. This is a DENSE service — all logic internalized via static methods.

**Structure (follow MetricsService file organization):**
```
// --- [CONSTANTS] -----------------------------------------------------------------
// --- [ERRORS] --------------------------------------------------------------------
// --- [SERVICES] ------------------------------------------------------------------
// --- [EXPORT] --------------------------------------------------------------------
```

**Service implementation:**

1. **Effect.Service class with scoped effect** — uses `scoped:` because it manages Redis connections:
   ```typescript
   class CacheService extends Effect.Service<CacheService>()("server/CacheService", {
     scoped: Effect.gen(function* () {
       // Setup Redis connections (pub and sub must be separate)
       // Setup @effect/experimental/PersistedCache for L1/L2
       // Return internal state
     }),
   }) { /* static methods */ }
   ```

2. **Internal state shape** — NOT exposed to consumers:
   - `_pub`: ioredis client for commands + publishing
   - `_caches`: Map of domain -> PersistedCache instance

3. **Constants section:**
   ```typescript
   const _config = {
     defaults: { capacity: 1000, ttl: Duration.minutes(5), inMemoryTTL: 10_000 },
     redis: { /* read from env */ },
   } as const;
   ```

4. **Static methods for core cache (this task):**

   a. `CacheService.get(domain, lookup)` — Returns a curried function `(key) => Effect<Option<V>>`:
      - Reads tenantId from `Context.Request.tenantId`
      - Reads session from `Context.Request.session` (optional)
      - Builds scoped key: `${tenantId}:${userId}:${domain}:${key}` or `${tenantId}:${domain}:${key}`
      - Uses PersistedCache for L1/L2 lookup with lookup callback
      - Wraps lookup with Resilience.wrap internally (timeout, retry)
      - Emits cache hit/miss metrics via MetricsService
      - Returns Option.some(value) or Option.none() on failure

   b. `CacheService.invalidate(domain, key)` — Local invalidation only (pub/sub added in Task 2):
      - Reads tenantId from context
      - Clears L1 cache for the key

   c. `CacheService.health()` — Returns `{ l1: boolean, l2: boolean }`:
      - L1 always true (memory)
      - L2 pings Redis, returns true/false

   d. `CacheService.redis` — Exposes Redis client for specialized services:
      - Returns `Effect.map(CacheService, s => s._pub)`
      - Used by totp-replay.ts for direct store access

**Key patterns from MetricsService to follow:**
- Single polymorphic function per concern (like MetricsService.label)
- Static methods that yield* CacheService internally
- Effect.serviceOption(MetricsService) for optional metric emission
- Derive types from schema, not separate declarations

**Key patterns from circuit.ts to follow:**
- const+namespace merge for CacheService export
- Namespace contains Config and Error types
- Registry pattern for cache instances (_caches Map)

**Anti-patterns to AVOID:**
- NO loose const exports (wrap, make, etc.)
- NO consumer-facing namespace parameter
- NO configurable resilience per call
- NO more than 1 internal helper function
- NO type exports that expose internal shapes

**Redis connection setup:**
- Use ioredis directly (already in catalog)
- Read config from environment via Effect.Config
- Graceful degradation: warn if Redis unavailable, continue with memory-only
  </action>
  <verify>
- Directory exists: packages/server/src/platform/
- File exists at packages/server/src/platform/cache.ts
- File has exactly 4 sections: CONSTANTS, ERRORS, SERVICES, EXPORT
- CacheService class extends Effect.Service
- Static methods: get, invalidate, health, redis
- No loose const/function exports outside namespace
- Maximum 1 helper function: `grep -c '^const _[a-z].*= (' packages/server/src/platform/cache.ts` returns 0 or 1
- Typecheck: `pnpm exec nx run server:typecheck`
  </verify>
  <done>
CacheService core is a proper Effect.Service class with L1/L2 architecture, auto-scope from FiberRef. Follows MetricsService polymorphic pattern exactly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add rate limiting and Redis pub/sub to CacheService</name>
  <files>packages/server/src/platform/cache.ts</files>
  <action>
Extend CacheService with rate limiting integration and Redis pub/sub for cross-instance invalidation.

**Changes to existing service:**

1. **Add _sub and _rateLimiter to internal state:**
   - `_sub`: ioredis client for subscribing (must be separate from _pub)
   - `_rateLimiter`: RateLimiter from @effect/experimental

2. **Add to constants section:**
   ```typescript
   const _config = {
     // ... existing
     pubsub: { channel: "cache:invalidate" },
   } as const;

   const _rateLimitPresets = {
     api: { algorithm: "token-bucket", limit: 100, tokens: 1, window: Duration.minutes(1) },
     auth: { algorithm: "fixed-window", limit: 5, tokens: 1, window: Duration.minutes(15) },
     mfa: { algorithm: "fixed-window", limit: 5, tokens: 1, window: Duration.minutes(15) },
     mutation: { algorithm: "token-bucket", limit: 100, tokens: 5, window: Duration.minutes(1) },
   } as const;
   ```

3. **Setup pub/sub in scoped effect with proper cleanup:**
   ```typescript
   scoped: Effect.gen(function* () {
     // ... existing Redis setup
     const sub = new Redis(redisConfig);
     yield* Effect.addFinalizer(() => Effect.sync(() => sub.unsubscribe()));

     // Subscribe to invalidation channel
     yield* Effect.tryPromise(() => sub.subscribe(_config.pubsub.channel));

     // Setup message handler for invalidation broadcasts
     sub.on("message", (channel, message) => {
       if (channel === _config.pubsub.channel) {
         const { domain, key, tenantId } = JSON.parse(message);
         // Clear L1 cache for the key
       }
     });

     // ... return state including sub
   }),
   ```

4. **Add static method:**

   `CacheService.rateLimit(preset)` — Returns Effect that consumes rate limit:
      - Uses integrated @effect/experimental/RateLimiter
      - Reads IP from Context.Request.ipAddress
      - Returns result or fails with RateLimitError
      - NO separate RateLimit.apply needed by consumers

5. **Update invalidate to broadcast:**
   - Publishes to Redis channel: `{ domain, key, tenantId }`
   - All instances receive message and clear L1 cache

**Rate limiting integration:**
- Use @effect/experimental/RateLimiter with Redis store
- Share Redis connection with cache (via _pub client)
- Presets match existing rate-limit.ts: api, auth, mfa, mutation
- Return structured result, not just boolean
  </action>
  <verify>
- CacheService.rateLimit static method exists
- _rateLimitPresets constant with api, auth, mfa, mutation
- Effect.addFinalizer for sub.unsubscribe() in scoped effect
- Invalidate publishes to Redis channel
- Typecheck: `pnpm exec nx run server:typecheck`
  </verify>
  <done>
CacheService has integrated rate limiting via static method and Redis pub/sub for cross-instance invalidation with proper cleanup via Effect.addFinalizer.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec nx run server:typecheck` passes
2. CacheService class exists with static methods: get, invalidate, health, rateLimit, redis
3. File structure matches MetricsService: CONSTANTS, ERRORS, SERVICES, EXPORT sections
4. No loose const/function exports — all logic inside class
5. Auto-scope pattern: Context.Request.tenantId and Context.Request.session used internally
6. Metric emission: Effect.serviceOption(MetricsService) pattern for cache hits/misses
7. Rate limit presets: api, auth, mfa, mutation available via CacheService.rateLimit
8. Polymorphic unity: `grep -c '^const _[a-z].*= (' packages/server/src/platform/cache.ts` returns 0 or 1
9. Pub/sub cleanup: grep for `Effect.addFinalizer.*unsubscribe` in cache.ts
</verification>

<success_criteria>
- CacheService.get() can be called without namespace parameter
- CacheService auto-derives scope from FiberRef context
- L1/L2 architecture via @effect/experimental/PersistedCache
- Redis pub/sub for invalidation (separate sub connection with Effect.addFinalizer cleanup)
- Rate limiting integrated via static method
- MetricsService integration for observability
- Code follows polymorphic unity — dense service, max 1 helper function
</success_criteria>

<output>
After completion, create `.planning/phases/01-platform-api-adoption/01-01-SUMMARY.md`
</output>
