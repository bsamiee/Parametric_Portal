---
phase: 01-platform-api-adoption
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/server/src/http/cache.ts
autonomous: true

must_haves:
  truths:
    - "Cache lookups automatically prefix keys with tenantId from FiberRef context"
    - "Multiple concurrent lookups for same key coalesce into single backend call"
    - "Cache hits/misses emit metrics via MetricsService"
    - "Cache operations compose with resilience (retry on transient failures)"
  artifacts:
    - path: "packages/server/src/http/cache.ts"
      provides: "Unified cache with tenant isolation and request deduplication"
      exports: ["Cache"]
      min_lines: 120
  key_links:
    - from: "packages/server/src/http/cache.ts"
      to: "packages/server/src/context.ts"
      via: "Context.Request.tenantId for key prefixing"
      pattern: "Context\\.Request\\.tenantId|tenantId"
    - from: "packages/server/src/http/cache.ts"
      to: "packages/server/src/http/resilience.ts"
      via: "Resilience patterns for fallback"
      pattern: "Resilience|withResilience|withFallback"
    - from: "packages/server/src/http/cache.ts"
      to: "effect"
      via: "Effect.Cache for request deduplication"
      pattern: "Cache\\.make|Cache\\."
---

<objective>
Build unified cache module with tenant isolation, request deduplication, and metrics integration.

Purpose: Replace scattered cache logic with single polymorphic API. Uses Effect.Cache for request deduplication (multiple concurrent lookups coalesce), automatic tenant key prefixing from FiberRef, and optional resilience patterns for fallback behavior.

Output: `packages/server/src/http/cache.ts` following metrics.ts polymorphic pattern
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-platform-api-adoption/01-RESEARCH.md
@.planning/phases/01-platform-api-adoption/01-01-SUMMARY.md (if available - resilience patterns)

Reference patterns:
@packages/server/src/observe/metrics.ts (polymorphic service pattern)
@packages/server/src/domain/session.ts (existing Cache.make usage in mfaEnabledCache)
@packages/server/src/context.ts (Context.Request.tenantId for isolation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cache module with tenant-isolated lookups</name>
  <files>packages/server/src/http/cache.ts</files>
  <action>
Create `packages/server/src/http/cache.ts` following the metrics.ts polymorphic pattern:

**File Structure:**
1. [CONSTANTS] - Default cache configurations
2. [TYPES] - Cache configuration types
3. [FUNCTIONS] - Pure helper functions
4. [SERVICES] - Cache factory and utilities
5. [EXPORT] - Named export only

**Core Concept - Tenant-Isolated Cache:**
The cache automatically prefixes all keys with tenantId from FiberRef context. This ensures tenant isolation without consumer ceremony.

```typescript
// Internal composite key structure
type CompositeKey<K> = { readonly tenantId: string; readonly key: K }

// Consumer just uses their key - tenantId added automatically
cache.get('user:123')  // Actually looks up `${tenantId}:user:123`
```

**Core Factory Function:**

```typescript
const make = <K, V, E, R>(config: {
  readonly name: string
  readonly capacity: number
  readonly lookup: (key: K) => Effect.Effect<V, E, R>
  readonly ttl: Duration.Duration
  readonly onHit?: (key: K) => Effect.Effect<void, never, R>
  readonly onMiss?: (key: K) => Effect.Effect<void, never, R>
}): Effect.Effect<Cache.Instance<K, V, E, R>, never, R>
```

**Returned Instance Interface:**

```typescript
interface Instance<K, V, E, R> {
  // Get with automatic tenant prefix - coalesces concurrent requests
  readonly get: (key: K) => Effect.Effect<V, E, R>

  // Get without coalescing (force fresh lookup)
  readonly getRefresh: (key: K) => Effect.Effect<V, E, R>

  // Invalidate specific key
  readonly invalidate: (key: K) => Effect.Effect<void, never, R>

  // Invalidate all keys for current tenant
  readonly invalidateAll: Effect.Effect<void, never, R>

  // Check if key exists (without triggering lookup)
  readonly contains: (key: K) => Effect.Effect<boolean, never, R>

  // Get cache stats
  readonly stats: Effect.Effect<Cache.Stats, never, never>
}
```

**Implementation Notes:**

1. **Tenant Key Prefixing:**
   ```typescript
   const get = (key: K) =>
     Effect.gen(function* () {
       const tenantId = yield* Context.Request.tenantId
       return yield* internalCache.get({ tenantId, key })
     })
   ```

2. **Effect.Cache for Deduplication:**
   - Use `Cache.make` from effect core
   - lookup function receives CompositeKey
   - TTL and capacity from config

3. **Metrics on Hit/Miss:**
   - If onHit/onMiss provided, call them
   - Default: emit to MetricsService.cache.hits / .misses

**Key Constraints:**
- Use Effect.Cache from 'effect' (NOT custom implementation)
- Tenant ID from Context.Request.tenantId (FiberRef)
- All cache operations return Effect (no Promise)
- Follow CLAUDE.md section separators exactly

**What NOT to do:**
- Do NOT implement Redis backend yet (Phase 3)
- Do NOT use KeyValueStore (Effect.Cache has different semantics)
- Do NOT hand-roll request coalescing
  </action>
  <verify>
1. File exists at packages/server/src/http/cache.ts
2. TypeScript compiles: `pnpm exec nx run server:typecheck`
3. Exports Cache.make factory function
4. Context.Request.tenantId used for key prefixing
5. Effect.Cache (from 'effect') used internally
  </verify>
  <done>
Cache module provides tenant-isolated caching with automatic key prefixing, request deduplication via Effect.Cache, and configurable TTL.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cache metrics and resilience integration</name>
  <files>packages/server/src/http/cache.ts</files>
  <action>
Extend cache module with metrics and resilience patterns:

**Metrics Integration:**

1. **Cache Metrics** - Add to MetricsService (or emit directly):
   ```typescript
   cache: {
     hits: Metric.counter('cache_hits_total'),
     misses: Metric.counter('cache_misses_total'),
     evictions: Metric.counter('cache_evictions_total'),
     lookupDuration: Metric.timerWithBoundaries('cache_lookup_duration_seconds', [0.001, 0.01, 0.1, 1])
   }
   ```

2. **Automatic Emission:**
   - On cache hit: increment hits with labels {name, tenant}
   - On cache miss: increment misses, track lookup duration
   - Evictions tracked if Effect.Cache provides hook

**Resilience Integration:**

Import from `../http/resilience.ts` and provide resilient lookup option:

```typescript
const make = <K, V, E, R>(config: {
  // ... existing config
  readonly resilience?: {
    readonly retry?: Schedule.Schedule<unknown, E, never>
    readonly timeout?: Duration.Duration
    readonly fallback?: (key: K) => Effect.Effect<V, never, R>
  }
})
```

When resilience configured:
```typescript
const lookup = (compositeKey: CompositeKey<K>) =>
  config.lookup(compositeKey.key).pipe(
    config.resilience?.retry ? Effect.retry(config.resilience.retry) : identity,
    config.resilience?.timeout ? Effect.timeout(config.resilience.timeout) : identity,
    config.resilience?.fallback ? Effect.catchAll(() => config.resilience.fallback(compositeKey.key)) : identity
  )
```

**Namespace and Types:**

```typescript
namespace Cache {
  export type Config<K, V, E, R> = Parameters<typeof make<K, V, E, R>>[0]
  export interface Instance<K, V, E, R> { /* as defined above */ }
  export interface Stats {
    readonly hits: number
    readonly misses: number
    readonly size: number
  }
}
```

**Key Constraint:** Resilience is OPTIONAL. If not configured, cache works without any retry/timeout/fallback.
  </action>
  <verify>
1. TypeScript compiles: `pnpm exec nx run server:typecheck`
2. MetricsService import present
3. Resilience import from ../http/resilience.ts (or inline patterns if simpler)
4. Cache.Stats type exported
  </verify>
  <done>
Cache module emits metrics for hits/misses/duration and optionally applies resilience patterns (retry, timeout, fallback) to lookup operations.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `pnpm exec nx run server:typecheck`
2. File structure follows CLAUDE.md section separators
3. Effect.Cache used for request deduplication
4. Context.Request.tenantId used for key isolation
5. Metrics emit on hit/miss
6. Resilience patterns available but optional
</verification>

<success_criteria>
- packages/server/src/http/cache.ts exists with ~150-200 LOC
- TypeScript compiles without errors
- Exports: Cache.make factory
- Instance methods: get, getRefresh, invalidate, invalidateAll, contains, stats
- Type exports: Cache.Config, Cache.Instance, Cache.Stats
- Automatic tenant key prefixing via Context.Request.tenantId
- Metrics for cache operations
- Optional resilience configuration
- Ready for session.ts and other services to migrate caching to
</success_criteria>

<output>
After completion, create `.planning/phases/01-platform-api-adoption/01-03-SUMMARY.md`
</output>
