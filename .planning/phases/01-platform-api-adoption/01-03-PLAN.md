---
phase: 01-platform-api-adoption
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - packages/server/src/security/rate-limit.ts
  - packages/server/src/security/totp-replay.ts
  - packages/server/src/http/cache.ts
  - packages/server/src/http/stream.ts
autonomous: true

must_haves:
  polymorphic_unity:
    max_helpers: 1
    verify: "grep -c '^const _[a-z].*= (' packages/server/src/security/rate-limit.ts | awk '$1 <= 1'"
  truths:
    - "rate-limit.ts uses CacheService.rateLimit() instead of standalone RateLimiter"
    - "totp-replay.ts uses CacheService.redis for Redis access"
    - "http/cache.ts is deleted — no longer exists"
    - "http/stream.ts is deleted — no longer exists"
    - "No import errors in any file that previously imported http/cache or http/stream"
  artifacts:
    - path: "packages/server/src/security/rate-limit.ts"
      provides: "Simplified rate limiting using CacheService"
      exports: ["RateLimit"]
    - path: "packages/server/src/security/totp-replay.ts"
      provides: "Replay guard using CacheService.redis"
      exports: ["ReplayGuardService"]
  key_links:
    - from: "rate-limit.ts"
      to: "CacheService"
      via: "CacheService.rateLimit static method"
      pattern: "CacheService\\.rateLimit"
    - from: "totp-replay.ts"
      to: "CacheService"
      via: "CacheService.redis for Redis client"
      pattern: "CacheService\\.redis"
---

<objective>
Migrate rate-limit.ts and totp-replay.ts to use CacheService, then delete the old http/cache.ts and http/stream.ts files.

Purpose: Complete the migration to platform services. Consumers should use CacheService instead of direct @effect/experimental APIs. Clean up absorbed files.

Output: Simplified rate-limit.ts, refactored totp-replay.ts, deleted http/cache.ts and http/stream.ts.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-platform-api-adoption/01-CONTEXT.md
@.planning/phases/01-platform-api-adoption/01-01-SUMMARY.md
@packages/server/src/platform/cache.ts
@packages/server/src/security/rate-limit.ts
@packages/server/src/security/totp-replay.ts
@packages/server/src/http/cache.ts
@packages/server/src/http/stream.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor rate-limit.ts to use CacheService</name>
  <files>packages/server/src/security/rate-limit.ts</files>
  <action>
Simplify rate-limit.ts to delegate to CacheService.rateLimit() instead of managing its own RateLimiter layer.

**Changes:**

1. **Remove Layer setup** — delete the `Default` layer that creates RateLimiter:
   - Delete layerStoreRedis configuration
   - Delete layerStoreMemory fallback
   - Delete the entire Default Layer composition

2. **Simplify apply function:**
   - Replace direct RateLimiter usage with CacheService.rateLimit(preset)
   - Keep the preset table (api, auth, mfa, mutation) for reference in metrics/audit
   - Keep the HttpError.RateLimit failure conversion
   - Keep the Context.Request.update for rateLimit state

3. **Keep headers middleware** — unchanged, still reads from Context.Request.rateLimit

4. **New structure:**
   ```typescript
   // --- [TABLE] -----------------------------------------------------------------
   const presets = { /* keep existing presets for documentation/audit */ } as const;

   // --- [FUNCTIONS] -------------------------------------------------------------
   const apply = <A, E, R>(preset: keyof typeof presets, handler: Effect.Effect<A, E, R>) =>
     Effect.gen(function* () {
       const result = yield* CacheService.rateLimit(preset);  // Delegates to CacheService
       yield* Context.Request.update({ rateLimit: Option.some(result) });
       // Keep existing audit logging
       return yield* handler;
     });

   const headers = /* unchanged */;

   // --- [ENTRY_POINT] -----------------------------------------------------------
   const RateLimit = { apply, headers, presets } as const;  // Remove Default layer
   ```

5. **Update imports:**
   - Remove @effect/experimental/RateLimiter imports
   - Remove @effect/experimental/RateLimiter/Redis imports
   - Add import for CacheService from '../platform/cache.ts'

**Key benefit:** No more duplicate Redis configuration. CacheService owns the Redis connection, rate-limit.ts just uses it.
  </action>
  <verify>
- RateLimit.Default layer is removed from exports
- RateLimit.apply calls CacheService.rateLimit(preset)
- No @effect/experimental/RateLimiter imports remain
- Typecheck passes: `pnpm exec nx run server:typecheck`
  </verify>
  <done>
rate-limit.ts simplified to delegate to CacheService.rateLimit(). No more standalone Layer management.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor totp-replay.ts to use CacheService.redis</name>
  <files>packages/server/src/security/totp-replay.ts</files>
  <action>
Modify totp-replay.ts to get its Redis client from CacheService instead of depending on RateLimiterStore.

**Changes:**

1. **Update service dependency:**
   - Replace `RateLimiterStore` dependency with access to CacheService.redis
   - Keep STM TMap for lockout state (per-worker, acceptable)

2. **Modify checkAndMark:**
   - Instead of `store.fixedWindow(...)`, use the Redis client directly
   - Implement simple SET NX with TTL for replay detection:
     ```typescript
     const redis = yield* CacheService.redis;
     const key = `${_config.keyPrefix}${userId}:${timeStep}:${code}`;
     const result = yield* Effect.tryPromise(() =>
       redis.set(key, "1", "PX", Duration.toMillis(_config.ttl), "NX")
     );
     return { alreadyUsed: result === null, backend: "redis" as const };
     ```

3. **Keep existing patterns:**
   - Keep STM TMap for lockout (checkLockout, recordFailure, recordSuccess)
   - Keep cleanup fiber for lockout map
   - Keep fail-open behavior on Redis errors

4. **Update imports:**
   - Remove @effect/experimental/RateLimiter import
   - Add import for CacheService from '../platform/cache.ts'

**Why not use CacheService.get?** TOTP replay is a write-once check, not a cache lookup. Direct Redis SET NX is the right primitive. CacheService.redis provides the connection without duplicate configuration.
  </action>
  <verify>
- No RateLimiterStore import remains
- CacheService.redis used for Redis access
- checkAndMark uses SET NX pattern
- STM TMap for lockout unchanged
- Typecheck passes: `pnpm exec nx run server:typecheck`
  </verify>
  <done>
totp-replay.ts uses CacheService.redis for Redis access. No more dependency on RateLimiterStore.
  </done>
</task>

<task type="auto">
  <name>Task 3: Delete absorbed files and update imports</name>
  <files>
    packages/server/src/http/cache.ts
    packages/server/src/http/stream.ts
  </files>
  <action>
Delete the old http/cache.ts and http/stream.ts files that have been absorbed into platform services.

**Steps:**

1. **Search for imports of http/cache.ts:**
   ```bash
   grep -r "from.*http/cache" packages/server/src/
   ```
   For each file found:
   - Replace `import { Cache } from '../http/cache.ts'` (or similar path)
   - With `import { CacheService } from '../platform/cache.ts'`
   - Update usage: Cache.make -> CacheService.get pattern

2. **Search for imports of http/stream.ts:**
   ```bash
   grep -r "from.*http/stream" packages/server/src/
   ```
   For each file found:
   - Replace `import { Streaming } from '../http/stream.ts'` (or similar path)
   - With `import { StreamingService } from '../platform/streaming.ts'`
   - Update usage: Streaming.sse -> StreamingService.sse, etc.

3. **Delete the files:**
   ```bash
   rm packages/server/src/http/cache.ts
   rm packages/server/src/http/stream.ts
   ```

4. **Verify no broken imports:**
   ```bash
   pnpm exec nx run server:typecheck
   ```

**Note:** If consumers use Cache.make pattern (creating cache instances), they need significant refactoring to use CacheService.get pattern instead. Document any complex migrations in the summary.
  </action>
  <verify>
- packages/server/src/http/cache.ts does not exist
- packages/server/src/http/stream.ts does not exist
- No imports of http/cache or http/stream in codebase
- Typecheck passes: `pnpm exec nx run server:typecheck`
  </verify>
  <done>
Old http/cache.ts and http/stream.ts deleted. All imports updated to use platform services.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec nx run server:typecheck` passes with no errors
2. `grep -r "from.*http/cache" packages/server/src/` returns nothing
3. `grep -r "from.*http/stream" packages/server/src/` returns nothing
4. packages/server/src/http/cache.ts does not exist
5. packages/server/src/http/stream.ts does not exist
6. rate-limit.ts exports RateLimit without Default layer
7. totp-replay.ts imports CacheService, not RateLimiterStore
8. Polymorphic unity: `grep -c '^const _[a-z].*= (' packages/server/src/security/rate-limit.ts` returns 0 or 1
</verification>

<success_criteria>
- rate-limit.ts delegates to CacheService.rateLimit()
- totp-replay.ts uses CacheService.redis for Redis access
- http/cache.ts and http/stream.ts are deleted
- All imports updated to platform services
- Typecheck passes
- No duplicate Redis configuration in codebase
</success_criteria>

<output>
After completion, create `.planning/phases/01-platform-api-adoption/01-03-SUMMARY.md`
</output>
