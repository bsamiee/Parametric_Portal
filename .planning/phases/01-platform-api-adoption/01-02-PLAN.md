---
phase: 01-platform-api-adoption
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/http/cookies.ts
autonomous: true

must_haves:
  truths:
    - "Cookie values are validated via Schema at read boundary"
    - "Cookie set operations use HttpServerResponse.setCookie with typed options"
    - "Missing optional cookies return Option.none, not errors"
    - "Cookie encryption remains in domain layer (oauth.ts), not cookies module"
  artifacts:
    - path: "packages/server/src/http/cookies.ts"
      provides: "Typed cookie operations with schema validation"
      exports: ["Cookies"]
      min_lines: 80
  key_links:
    - from: "packages/server/src/http/cookies.ts"
      to: "@effect/platform"
      via: "HttpServerRequest.schemaCookies import"
      pattern: "HttpServerRequest.*schemaCookies|schemaCookies"
    - from: "packages/server/src/http/cookies.ts"
      to: "effect"
      via: "Schema import for cookie validation"
      pattern: "Schema|S\\."
---

<objective>
Build unified cookies module using @effect/platform Cookies with schema validation at boundary.

Purpose: Replace manual cookie parsing with typed Effect operations. All cookie I/O goes through schema validation, eliminating parsing bugs and providing type-safe access. Encryption remains separate concern in oauth.ts.

Output: `packages/server/src/http/cookies.ts` following metrics.ts polymorphic pattern
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-platform-api-adoption/01-RESEARCH.md

Reference patterns:
@packages/server/src/observe/metrics.ts (polymorphic service pattern)
@packages/server/src/context.ts (existing Context.Request.cookie implementation to replace)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cookies module with schema validation</name>
  <files>packages/server/src/http/cookies.ts</files>
  <action>
Create `packages/server/src/http/cookies.ts` following the metrics.ts polymorphic pattern:

**File Structure:**
1. [CONSTANTS] - Cookie configurations (name, options per cookie type)
2. [SCHEMA] - Cookie value schemas for validation
3. [FUNCTIONS] - Pure helper functions
4. [SERVICES] - CookiesService or static Cookies namespace
5. [EXPORT] - Named export only

**Cookie Schemas to Define:**

```typescript
// Refresh token cookie - required string
const RefreshTokenSchema = S.Struct({
  refreshToken: S.String
})

// OAuth state cookie - required string (encrypted at domain layer)
const OAuthStateSchema = S.Struct({
  oauthState: S.String
})

// Session token cookie - optional (may not exist on first visit)
const SessionTokenSchema = S.Struct({
  sessionToken: S.optional(S.String)
})
```

**Cookie Configurations:**
```typescript
const _config = {
  oauth: {
    name: 'oauthState',
    options: {
      httpOnly: true,
      maxAge: Duration.minutes(10),
      path: '/api/auth/oauth',
      sameSite: 'lax',
      secure: isProduction
    }
  },
  refresh: {
    name: 'refreshToken',
    options: {
      httpOnly: true,
      maxAge: Duration.days(30),
      path: '/api/auth',
      sameSite: 'lax',
      secure: isProduction
    }
  }
} as const
```

**Core Operations:**

1. **Read with Schema Validation:**
   ```typescript
   // Read and validate - returns Effect with typed value
   const read = <S extends S.Schema.AnyNoContext>(
     schema: S
   ): Effect.Effect<S.Schema.Type<S>, ParseError, HttpServerRequest.HttpServerRequest>

   // Usage: yield* Cookies.read(RefreshTokenSchema)
   ```

2. **Read Optional (no error on missing):**
   ```typescript
   const readOptional = <S extends S.Schema.AnyNoContext>(
     schema: S
   ): Effect.Effect<Option.Option<S.Schema.Type<S>>, never, HttpServerRequest.HttpServerRequest>
   ```

3. **Set Cookie:**
   ```typescript
   const set = (
     key: CookieKey,
     value: string
   ) => (res: HttpServerResponse.HttpServerResponse): Effect.Effect<HttpServerResponse.HttpServerResponse, CookiesError>

   // Usage: yield* HttpServerResponse.empty().pipe(Cookies.set('refresh', token))
   ```

4. **Clear Cookie:**
   ```typescript
   const clear = (
     key: CookieKey
   ) => (res: HttpServerResponse.HttpServerResponse): HttpServerResponse.HttpServerResponse

   // Usage: yield* HttpServerResponse.empty().pipe(Cookies.clear('refresh'))
   ```

5. **Pre-built Accessors** for common cookies:
   ```typescript
   const refreshToken = read(RefreshTokenSchema).pipe(
     Effect.map(c => c.refreshToken)
   )

   const oauthState = read(OAuthStateSchema).pipe(
     Effect.map(c => c.oauthState)
   )
   ```

**Key Constraints:**
- Use HttpServerRequest.schemaCookies from @effect/platform (NOT manual parsing)
- Cookie options from existing context.ts _cookie config
- isProduction detection from process.env.API_BASE_URL
- Schema validation errors become ParseError (not custom types)
- Follow CLAUDE.md section separators exactly

**What NOT to do:**
- Do NOT handle encryption - that stays in oauth.ts domain logic
- Do NOT create wrapper types over @effect/platform Cookie types
- Do NOT use try/catch - use Effect.catchTag for error handling
- Do NOT re-export types from @effect/platform
  </action>
  <verify>
1. File exists at packages/server/src/http/cookies.ts
2. TypeScript compiles: `pnpm exec nx run server:typecheck`
3. Exports Cookies namespace with: read, readOptional, set, clear, refreshToken, oauthState
4. HttpServerRequest.schemaCookies is used (not manual parsing)
  </verify>
  <done>
Cookies module provides typed read/write operations with schema validation at boundary. All cookies use @effect/platform primitives directly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cookie type discriminators and namespace</name>
  <files>packages/server/src/http/cookies.ts</files>
  <action>
Add TypeScript namespace and type exports following the const+namespace merge pattern from context.ts:

**Type Exports:**
```typescript
// biome-ignore lint/correctness/noUnusedVariables: const+namespace merge
const Cookies = { read, readOptional, set, clear, refreshToken, oauthState, ... } as const

namespace Cookies {
  export type Key = keyof typeof _config
  export type Options = Cookie['options']
  export type RefreshToken = S.Schema.Type<typeof RefreshTokenSchema>
  export type OAuthState = S.Schema.Type<typeof OAuthStateSchema>
}

export { Cookies }
```

**Why const+namespace merge:**
- Single import: `import { Cookies } from '../http/cookies.ts'`
- Access values: `Cookies.read(...)`, `Cookies.set(...)`
- Access types: `Cookies.Key`, `Cookies.RefreshToken`
- Follows existing pattern in context.ts, circuit.ts

**Error Handling Strategy:**
- ParseError from schema validation → propagate (caller decides how to handle)
- CookiesError from set operation → propagate
- Missing optional cookie → Option.none() (not an error)

Document error types in JSDoc comments for each operation.
  </action>
  <verify>
1. TypeScript compiles: `pnpm exec nx run server:typecheck`
2. Cookies.Key type exists
3. Cookies namespace exports types alongside values
  </verify>
  <done>
Cookies module exports unified namespace with both values (operations) and types (Key, Options, etc.) following codebase patterns.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `pnpm exec nx run server:typecheck`
2. File structure follows CLAUDE.md section separators
3. HttpServerRequest.schemaCookies used for reading
4. HttpServerResponse.setCookie used for writing
5. No manual cookie string parsing anywhere
6. Encryption NOT handled (stays in oauth.ts)
</verification>

<success_criteria>
- packages/server/src/http/cookies.ts exists with ~100-150 LOC
- TypeScript compiles without errors
- Exports: Cookies.read, Cookies.readOptional, Cookies.set, Cookies.clear
- Pre-built accessors: Cookies.refreshToken, Cookies.oauthState
- Type exports: Cookies.Key, Cookies.Options
- Uses @effect/platform schemaCookies (verified by import)
- Ready for oauth.ts and auth routes to migrate to
</success_criteria>

<output>
After completion, create `.planning/phases/01-platform-api-adoption/01-02-SUMMARY.md`
</output>
