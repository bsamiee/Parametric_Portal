---
phase: 01-platform-api-adoption
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/platform/streaming.ts
autonomous: true

must_haves:
  polymorphic_unity:
    max_helpers: 1
    verify: "grep -c '^const _[a-z].*= (' packages/server/src/platform/streaming.ts | awk '$1 <= 1'"
  truths:
    - "StreamingService.sse() returns HttpServerResponse with SSE encoding"
    - "StreamingService.download() returns HttpServerResponse with binary stream"
    - "StreamingService.export() returns HttpServerResponse with json/csv/ndjson encoding"
    - "Buffer strategy is intelligent per type — sliding for SSE, suspend for downloads/exports"
    - "Metrics tracked automatically for all stream types"
    - "Heartbeat included for SSE streams"
    - "Cleanup runs via Effect.ensuring on stream termination"
  artifacts:
    - path: "packages/server/src/platform/streaming.ts"
      provides: "StreamingService Effect.Service class with unified streaming"
      exports: ["StreamingService"]
  key_links:
    - from: "StreamingService"
      to: "MetricsService"
      via: "Effect.serviceOption for metric emission"
      pattern: "Effect\\.serviceOption\\(MetricsService\\)"
    - from: "StreamingService"
      to: "HttpServerResponse"
      via: "HttpServerResponse.stream for response creation"
      pattern: "HttpServerResponse\\.stream"
---

<objective>
Create StreamingService as a proper Effect.Service class following the MetricsService polymorphic pattern.

Purpose: Replace loose http/stream.ts wrapper with a dense, intelligent service that provides unified streaming for SSE, binary downloads, and formatted exports with intelligent backpressure defaults.

Output: Single StreamingService class at packages/server/src/platform/streaming.ts with static methods for sse, download, and export.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-platform-api-adoption/01-CONTEXT.md
@.planning/phases/01-platform-api-adoption/01-RESEARCH.md
@packages/server/src/observe/metrics.ts
@packages/server/src/http/stream.ts
@packages/server/src/context.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StreamingService with unified streaming API</name>
  <files>packages/server/src/platform/streaming.ts</files>
  <action>
**NOTE:** The `packages/server/src/platform/` directory will be created by Plan 01-01 (which runs in the same wave). If executing in isolation, create it first:
```bash
mkdir -p packages/server/src/platform
```

Create StreamingService following the MetricsService polymorphic pattern exactly. This is a DENSE service — all logic internalized via static methods.

**Structure (follow MetricsService file organization):**
```
// --- [CONSTANTS] -----------------------------------------------------------------
// --- [SERVICES] ------------------------------------------------------------------
// --- [EXPORT] --------------------------------------------------------------------
```

**Service implementation:**

1. **Effect.Service class with simple effect** — no scoped resources needed:
   ```typescript
   class StreamingService extends Effect.Service<StreamingService>()("server/StreamingService", {
     effect: Effect.succeed({}),
   }) { /* static methods */ }
   ```

2. **Constants section:**
   ```typescript
   const _buffers = {
     sse:      { capacity: 64,  strategy: "sliding"  },  // Drop stale events for real-time
     download: { capacity: 256, strategy: "suspend"  },  // Wait for consumer
     export:   { capacity: 128, strategy: "suspend"  },  // Wait for consumer
   } as const;

   const _heartbeat = Duration.seconds(30);
   ```

3. **Static methods (polymorphic API):**

   a. `StreamingService.sse(name, events, serialize)`:
      - `name`: Stream identifier for metrics
      - `events`: Stream.Stream<A, E, never> of domain events
      - `serialize`: (a: A) => { data: string; event?: string; id?: string }
      - Returns: Effect<HttpServerResponse, never, MetricsService>

      Pipeline (in order):
      1. Metrics tracking (before buffer): Stream.tap to increment stream.elements
      2. Buffer with sliding strategy: Stream.buffer({ capacity: 64, strategy: "sliding" })
      3. Encode to SSE format: Use @effect/experimental Sse.encoder
      4. Heartbeat: Stream.merge with scheduled `: heartbeat\n\n`
      5. Cleanup logging: Stream.ensuring(Effect.logDebug("SSE stream closed"))
      6. Return: HttpServerResponse.stream with text/event-stream content type

      **Important:** Buffer BEFORE encoding — lets sliding strategy drop stale domain objects, not encoded strings.

   b. `StreamingService.download(stream, config)`:
      - `stream`: Stream.Stream<Uint8Array, E, never> of binary data
      - `config`: { filename: string; contentType: string; size?: number }
      - Returns: HttpServerResponse (sync, no Effect wrapper needed)

      Pipeline:
      1. Buffer with suspend strategy: Stream.buffer({ capacity: 256, strategy: "suspend" })
      2. Headers: Content-Type, Content-Disposition (attachment), Content-Length (if size known)
      3. Return: HttpServerResponse.stream

   c. `StreamingService.export(name, stream, format, serialize?)`:
      - `name`: Export identifier for metrics
      - `stream`: Stream.Stream<A, E, never> of domain objects
      - `format`: "json" | "csv" | "ndjson"
      - `serialize?`: Optional (a: A) => string, defaults to JSON.stringify
      - Returns: Effect<HttpServerResponse, never, MetricsService>

      Pipeline:
      1. Metrics tracking: Stream.tap to increment stream.elements
      2. Format encoding (Match.value on format):
         - json: `[` + comma-separated + `]`
         - ndjson: each line `${serialize(a)}\n`
         - csv: each line `${serialize(a)}\n`
      3. Buffer with suspend strategy: Stream.buffer({ capacity: 128, strategy: "suspend" })
      4. Headers: Content-Type per format, Content-Disposition attachment
      5. Return: HttpServerResponse.stream

**Key patterns from MetricsService to follow:**
- Static methods that yield* StreamingService internally (even if service has no state)
- Effect.serviceOption(MetricsService) for optional metric emission
- Single responsibility per method — no config sprawl

**Key differences from old http/stream.ts:**
- NO consumer-configurable buffer options
- NO consumer-configurable retry/timeout (that's source-level via Resilience.wrap)
- NO onError callback — errors propagate through stream
- NO onCleanup callback — use Effect.ensuring internally
- Intelligent defaults baked in, not configurable

**Anti-patterns to AVOID:**
- NO loose const exports (sse, response, export_ etc.)
- NO buffer config parameters in API
- NO timeout/retry parameters (source-level concern)
- NO more than 1 internal helper function

**Metrics integration:**
- Read tenantId from Context.Request.tenantId (with fallback to "system")
- Use MetricsService.label for labels
- Increment stream.elements counter per element
- Track stream.bytes for binary downloads (optional optimization)
  </action>
  <verify>
- File exists at packages/server/src/platform/streaming.ts
- File has exactly 3 sections: CONSTANTS, SERVICES, EXPORT
- StreamingService class extends Effect.Service
- Static methods: sse, download, export
- No loose const/function exports outside namespace
- No buffer config parameters in any method signature
- Maximum 1 helper function
- Typecheck: `pnpm exec nx run server:typecheck`
  </verify>
  <done>
StreamingService is a proper Effect.Service class with unified sse(), download(), and export() methods. Intelligent backpressure defaults per stream type. Metrics tracked automatically. Follows MetricsService polymorphic pattern exactly.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec nx run server:typecheck` passes
2. StreamingService class exists with static methods: sse, download, export
3. File structure matches MetricsService: CONSTANTS, SERVICES, EXPORT sections
4. No buffer configuration in method signatures
5. Intelligent defaults: sliding for SSE, suspend for download/export
6. Metric emission: Effect.serviceOption(MetricsService) pattern
7. SSE includes heartbeat via Stream.merge
8. Polymorphic unity: `grep -c '^const _[a-z].*= (' packages/server/src/platform/streaming.ts` returns 0 or 1
</verification>

<success_criteria>
- StreamingService.sse() returns SSE-encoded response with heartbeat
- StreamingService.download() returns binary response with proper headers
- StreamingService.export() returns formatted response (json/csv/ndjson)
- No consumer configuration for buffers — intelligent defaults only
- Metrics tracked automatically for all stream types
- Code follows polymorphic unity — dense service, max 1 helper function
</success_criteria>

<output>
After completion, create `.planning/phases/01-platform-api-adoption/01-02-SUMMARY.md`
</output>
