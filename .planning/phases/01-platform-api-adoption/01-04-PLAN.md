---
phase: 01-platform-api-adoption
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/server/src/http/stream.ts
autonomous: true

must_haves:
  truths:
    - "SSE streams use @effect/experimental Sse encoder without manual TextEncoder string building"
    - "All streams have explicit buffer configuration preventing unbounded memory growth"
    - "Stream operations emit metrics for throughput and buffer utilization"
    - "Streams compose with resilience (circuit breaker for cascade prevention)"
  artifacts:
    - path: "packages/server/src/http/stream.ts"
      provides: "Unified streaming with SSE encoding and backpressure control"
      exports: ["Streaming"]
      min_lines: 150
  key_links:
    - from: "packages/server/src/http/stream.ts"
      to: "@effect/experimental"
      via: "Sse encoder import"
      pattern: "Sse|@effect/experimental"
    - from: "packages/server/src/http/stream.ts"
      to: "@effect/platform"
      via: "HttpServerResponse.stream"
      pattern: "HttpServerResponse\\.stream"
    - from: "packages/server/src/http/stream.ts"
      to: "effect"
      via: "Stream buffer strategies"
      pattern: "Stream\\.buffer|buffer.*capacity.*strategy"
---

<objective>
Build unified streaming module with SSE encoding, backpressure control, and metrics integration.

Purpose: Replace manual SSE string formatting and unbounded buffers with official Effect primitives. Single polymorphic API for all streaming: SSE events, file downloads, data exports. Intelligent buffer defaults per stream type, circuit breaker integration for cascade prevention.

Output: `packages/server/src/http/stream.ts` following metrics.ts polymorphic pattern
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-platform-api-adoption/01-RESEARCH.md
@.planning/phases/01-platform-api-adoption/01-01-SUMMARY.md (if available - resilience patterns)

Reference patterns:
@packages/server/src/observe/metrics.ts (polymorphic service pattern, trackStream, trackStreamProgress)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create streaming module with SSE encoding</name>
  <files>packages/server/src/http/stream.ts</files>
  <action>
Create `packages/server/src/http/stream.ts` following the metrics.ts polymorphic pattern:

**File Structure:**
1. [CONSTANTS] - Default buffer configs, SSE headers
2. [TYPES] - Stream configuration types
3. [FUNCTIONS] - Pure encoding/buffering helpers
4. [SERVICES] - Streaming utilities (static namespace, not service class)
5. [EXPORT] - Named export only

**Buffer Strategy Constants:**

```typescript
const _bufferDefaults = {
  sse: { capacity: 64, strategy: 'sliding' },      // Real-time, drop stale
  download: { capacity: 256, strategy: 'suspend' }, // Backpressure for files
  export: { capacity: 128, strategy: 'suspend' },   // Backpressure for data
  import: { capacity: 64, strategy: 'suspend' },    // Controlled intake
} as const satisfies Record<string, { capacity: number; strategy: 'suspend' | 'sliding' | 'dropping' }>
```

**SSE Response Builder:**

```typescript
const sse = <A, E, R>(
  events: Stream.Stream<A, E, R>,
  config: {
    readonly serialize: (a: A) => { id?: string; event?: string; data: string }
    readonly buffer?: { capacity?: number; strategy?: 'sliding' | 'suspend' | 'dropping' }
    readonly onError?: (e: E) => { event: string; data: string }
  }
): Effect.Effect<HttpServerResponse.HttpServerResponse, never, R>
```

**Implementation:**
```typescript
const sse = (events, config) => {
  const bufferConfig = { ..._bufferDefaults.sse, ...config.buffer }

  const sseStream = events.pipe(
    Stream.map((a) => {
      const { id, event, data } = config.serialize(a)
      // Use @effect/experimental Sse encoder
      return Sse.encode({
        _tag: "ServerSentEvent",
        event: event ?? "message",
        data,
        id,
      })
    }),
    Stream.catchAll((e) =>
      config.onError
        ? Stream.succeed(Sse.encode({ _tag: "ServerSentEvent", ...config.onError(e) }))
        : Stream.fail(e)
    ),
    Stream.buffer(bufferConfig)
  )

  return HttpServerResponse.stream(sseStream, {
    contentType: "text/event-stream",
    headers: Headers.fromInput({
      "Cache-Control": "no-cache",
      "Connection": "keep-alive",
    }),
  })
}
```

**Generic Stream Response:**

```typescript
const response = <E, R>(
  stream: Stream.Stream<Uint8Array, E, R>,
  config: {
    readonly contentType: string
    readonly headers?: Headers.Input
    readonly buffer?: { capacity?: number; strategy?: 'sliding' | 'suspend' | 'dropping' }
  }
): Effect.Effect<HttpServerResponse.HttpServerResponse, never, R>
```

**Buffer Utility:**

```typescript
const withBuffer = <A, E, R>(
  stream: Stream.Stream<A, E, R>,
  type: keyof typeof _bufferDefaults | { capacity: number; strategy: 'sliding' | 'suspend' | 'dropping' }
): Stream.Stream<A, E, R>
```

**Key Constraints:**
- Use @effect/experimental Sse.encode for SSE formatting
- Use Stream.buffer with explicit capacity (NEVER unbounded)
- Use HttpServerResponse.stream for response
- Follow CLAUDE.md section separators exactly

**What NOT to do:**
- Do NOT build SSE strings manually (`data: ${json}\n\n`)
- Do NOT use unbounded buffers (no `capacity: "unbounded"`)
- Do NOT use TextEncoder directly for SSE (Sse.encode handles it)
- Do NOT implement worker pool integration (Phase 3)
  </action>
  <verify>
1. File exists at packages/server/src/http/stream.ts
2. TypeScript compiles: `pnpm exec nx run server:typecheck`
3. Exports Streaming.sse, Streaming.response, Streaming.withBuffer
4. @effect/experimental Sse import present
5. All Stream.buffer calls have explicit capacity
  </verify>
  <done>
Streaming module provides SSE encoding via @effect/experimental and generic stream responses with explicit buffer configuration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add stream metrics and resilience integration</name>
  <files>packages/server/src/http/stream.ts</files>
  <action>
Extend streaming module with metrics and resilience patterns:

**Metrics Integration:**

1. **Stream Throughput Metrics:**
   ```typescript
   stream: {
     elements: Metric.counter('stream_elements_total'),
     bytes: Metric.counter('stream_bytes_total'),
     duration: Metric.timerWithBoundaries('stream_duration_seconds', [0.1, 1, 10, 60, 300]),
     bufferOverflows: Metric.counter('stream_buffer_overflows_total'),
   }
   ```

2. **Tracked SSE Variant:**
   ```typescript
   const sseTracked = <A, E, R>(
     events: Stream.Stream<A, E, R>,
     config: {
       readonly name: string  // For metric labels
       readonly serialize: (a: A) => { id?: string; event?: string; data: string }
       readonly buffer?: { capacity?: number; strategy?: 'sliding' | 'suspend' | 'dropping' }
     }
   ): Effect.Effect<HttpServerResponse.HttpServerResponse, never, R | MetricsService>
   ```

   Internally:
   ```typescript
   // Track element count
   const tracked = events.pipe(
     Stream.tap(() => MetricsService.inc(metrics.stream.elements, labels)),
     Stream.buffer(bufferConfig)
   )
   ```

3. **Leverage Existing MetricsService.trackStream:**
   - Use existing pattern from metrics.ts
   - Add stream-specific extensions

**Resilience Integration:**

Import from `../http/resilience.ts` and provide circuit-protected streaming:

```typescript
const withCircuit = <A, E, R>(
  stream: Stream.Stream<A, E, R>,
  circuitName: string
): Stream.Stream<A, E | BrokenCircuitError, R>
```

When circuit opens:
- Stream terminates with BrokenCircuitError
- Prevents cascade failures from runaway streams

**Progress Tracking (from metrics.ts):**

Expose progress tracking for long-running streams:
```typescript
const withProgress = <A, E, R>(
  stream: Stream.Stream<A, E, R>,
  config: {
    readonly name: string
    readonly logInterval?: number  // Log every N elements
  }
): Stream.Stream<A, E, R | MetricsService>
```

**Namespace and Types:**

```typescript
namespace Streaming {
  export type BufferStrategy = 'sliding' | 'suspend' | 'dropping'
  export type BufferConfig = { capacity: number; strategy: BufferStrategy }
  export type SseConfig<A> = Parameters<typeof sse<A, any, any>>[1]
  export type ResponseConfig = Parameters<typeof response<any, any>>[1]
}
```

**Key Constraint:** Metrics are OPTIONAL. Basic streaming works without MetricsService.
  </action>
  <verify>
1. TypeScript compiles: `pnpm exec nx run server:typecheck`
2. MetricsService import present
3. Streaming.sseTracked variant exists
4. Streaming.withCircuit variant exists
5. Streaming.withProgress variant exists
  </verify>
  <done>
Streaming module emits throughput metrics, supports circuit breaker integration for cascade prevention, and provides progress tracking for long-running streams.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add specialized stream builders</name>
  <files>packages/server/src/http/stream.ts</files>
  <action>
Add pre-built stream builders for common patterns:

**File Download Stream:**
```typescript
const download = <E, R>(
  stream: Stream.Stream<Uint8Array, E, R>,
  config: {
    readonly filename: string
    readonly contentType?: string
    readonly size?: number
  }
): Effect.Effect<HttpServerResponse.HttpServerResponse, never, R>
```

Sets headers:
- Content-Disposition: attachment; filename="..."
- Content-Type: (from config or application/octet-stream)
- Content-Length: (if size provided)
- Uses download buffer config

**Data Export Stream:**
```typescript
const export_ = <A, E, R>(  // export_ to avoid keyword
  stream: Stream.Stream<A, E, R>,
  config: {
    readonly filename: string
    readonly format: 'json' | 'csv' | 'ndjson'
    readonly serialize?: (a: A) => string
  }
): Effect.Effect<HttpServerResponse.HttpServerResponse, never, R>
```

Format-specific:
- json: Wrap in array brackets, comma-separate
- csv: Header row, then data rows
- ndjson: Newline-delimited JSON

**Chunked Upload Stream (for receiving):**
```typescript
const fromMultipart = (
  request: HttpServerRequest.HttpServerRequest,
  config?: {
    readonly maxSize?: number
    readonly allowedTypes?: readonly string[]
  }
): Stream.Stream<HttpMultipart.Part, HttpError.Validation, never>
```

Validates:
- File size against maxSize
- Content-Type against allowedTypes
- Returns stream of parts for processing

**Common Patterns:**

```typescript
// JSON array stream
const jsonArray = <A, E, R>(
  stream: Stream.Stream<A, E, R>,
  serialize: (a: A) => string = JSON.stringify
): Stream.Stream<Uint8Array, E, R>

// NDJSON stream (one JSON per line)
const ndjson = <A, E, R>(
  stream: Stream.Stream<A, E, R>,
  serialize: (a: A) => string = JSON.stringify
): Stream.Stream<Uint8Array, E, R>
```

**Key Constraint:** These are convenience builders. They compose the core primitives (response, withBuffer, metrics).
  </action>
  <verify>
1. TypeScript compiles: `pnpm exec nx run server:typecheck`
2. Streaming.download exists
3. Streaming.export_ exists
4. Streaming.jsonArray and Streaming.ndjson exist
  </verify>
  <done>
Streaming module provides pre-built builders for common patterns: file downloads, data exports (JSON/CSV/NDJSON), and multipart uploads.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `pnpm exec nx run server:typecheck`
2. File structure follows CLAUDE.md section separators
3. @effect/experimental Sse used for SSE encoding
4. All buffers have explicit capacity (grep for "unbounded" should find nothing)
5. HttpServerResponse.stream used for responses
6. Metrics integrate with MetricsService pattern
7. Circuit breaker integration available
</verification>

<success_criteria>
- packages/server/src/http/stream.ts exists with ~250-300 LOC
- TypeScript compiles without errors
- Core exports: Streaming.sse, Streaming.response, Streaming.withBuffer
- Tracked variants: Streaming.sseTracked, Streaming.withProgress
- Resilience: Streaming.withCircuit
- Builders: Streaming.download, Streaming.export_, Streaming.jsonArray, Streaming.ndjson
- Type exports: Streaming.BufferStrategy, Streaming.BufferConfig, Streaming.SseConfig
- No unbounded buffers anywhere
- @effect/experimental Sse encoder used (verified by import)
- Ready for route handlers to migrate streaming to
</success_criteria>

<output>
After completion, create `.planning/phases/01-platform-api-adoption/01-04-SUMMARY.md`
</output>
