---
phase: 04-job-processing
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - packages/server/src/observe/metrics.ts
autonomous: true

must_haves:
  truths:
    - "jobs.dlqSize gauge exists in MetricsService"
    - "jobs.cancellations counter exists in MetricsService"
    - "jobs.processingSeconds histogram exists in MetricsService"
    - "MetricsService.trackJob static helper exists"
    - "trackJob signature matches Plan 04-02 usage"
    - "Match import verified present in metrics.ts"
  artifacts:
    - path: "packages/server/src/observe/metrics.ts"
      provides: "Extended job metrics + trackJob helper"
      contains: "trackJob"
  key_links:
    - from: "packages/server/src/observe/metrics.ts"
      to: "effect"
      via: "Metric API"
      pattern: "Metric\\.(counter|gauge|timerWithBoundaries)"
    - from: "packages/server/src/observe/metrics.ts"
      to: "packages/server/src/infra/jobs.ts"
      via: "trackJob called from JobEntityLive"
      pattern: "MetricsService\\.trackJob"
---

<objective>
Extend MetricsService with Phase 4 job metrics and trackJob helper.

Purpose: Job processing needs metrics for cancellations, DLQ size, processing duration, and a standardized tracking helper. Plan 04-02 uses `MetricsService.trackJob` for job operation instrumentation.
Output: Updated MetricsService with complete job.* metrics and trackJob static method.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-job-processing/04-RESEARCH.md
@.planning/phases/04-job-processing/04-02-PLAN.md
@packages/server/src/observe/metrics.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify Match import exists in metrics.ts</name>
  <files>packages/server/src/observe/metrics.ts</files>
  <action>
Verify Match is already imported in metrics.ts (line 6). If not present, add it to the effect import statement.

**Expected import line (metrics.ts:6):**
```typescript
import { Boolean as B, Effect, HashSet, Match, Metric, MetricLabel, Stream } from 'effect';
```

**Check:**
- `Match` should be in the import statement for the trackJob helper to work
- If missing, add `Match` to the import destructuring

**No changes needed if Match is already present.**
  </action>
  <verify>grep 'Match' packages/server/src/observe/metrics.ts | head -3</verify>
  <done>Match import verified present in metrics.ts effect imports</done>
</task>

<task type="auto">
  <name>Task 2: Add missing job metrics to MetricsService</name>
  <files>packages/server/src/observe/metrics.ts</files>
  <action>
Extend the existing `jobs` section in MetricsService (lines 95-104) with metrics required by Phase 4.

**Current jobs metrics (already present):**
- completions: counter
- deadLettered: counter
- duration: histogram
- enqueued: counter
- failures: counter
- queueDepth: gauge
- retries: counter
- waitDuration: histogram

**Add these metrics in alphabetical order within jobs object:**

```typescript
jobs: {
  cancellations: Metric.counter('jobs_cancelled_total'),  // NEW: after completions
  completions: Metric.counter('jobs_completed_total'),
  deadLettered: Metric.counter('jobs_dead_lettered_total'),
  dlqSize: Metric.gauge('jobs_dlq_size'),                 // NEW: after deadLettered
  duration: Metric.timerWithBoundaries('jobs_duration_seconds', _boundaries.jobs),
  enqueued: Metric.counter('jobs_enqueued_total'),
  failures: Metric.counter('jobs_failed_total'),
  processingSeconds: Metric.timerWithBoundaries('jobs_processing_seconds', _boundaries.jobs),  // NEW: after failures
  queueDepth: Metric.gauge('jobs_queue_depth'),
  retries: Metric.counter('jobs_retried_total'),
  waitDuration: Metric.timerWithBoundaries('jobs_wait_duration_seconds', _boundaries.jobs),
},
```

**Metric purposes:**
- `cancellations`: Incremented by cancel handler in jobs.ts
- `dlqSize`: Updated when jobs dead-letter (for observability dashboards)
- `processingSeconds`: Active processing time (distinct from duration which is end-to-end)
  </action>
  <verify>pnpm exec nx run @parametric-portal/server:typecheck</verify>
  <done>MetricsService.jobs includes cancellations, dlqSize, processingSeconds metrics</done>
</task>

<task type="auto">
  <name>Task 3: Add trackJob static helper</name>
  <files>packages/server/src/observe/metrics.ts</files>
  <action>
Add a static helper method to MetricsService for consistent job instrumentation. Place after trackCluster (around line 282).

**Signature must match Plan 04-02 usage:**
```typescript
MetricsService.trackJob({ jobType: envelope.type, operation: 'process', priority: envelope.priority })
```

**Add after trackCluster static method:**

```typescript
// --- [JOB_TRACKING] ----------------------------------------------------------
/** Track job operation with type and priority labels. Labels errors by reason for JobError. */
static readonly trackJob = <A, E extends { readonly reason: string }, R>(
  config: {
    readonly operation: 'submit' | 'process' | 'cancel' | 'replay';
    readonly jobType: string;
    readonly priority?: string;
  },
) => (effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R | MetricsService> =>
  Effect.flatMap(MetricsService, (metrics) => {
    const labels = MetricsService.label({
      job_type: config.jobType,
      operation: config.operation,
      priority: config.priority,
    });
    return effect.pipe(
      Effect.tap(() => Match.value(config.operation).pipe(
        Match.when('submit', () => Metric.increment(Metric.taggedWithLabels(metrics.jobs.enqueued, labels))),
        Match.when('cancel', () => Metric.increment(Metric.taggedWithLabels(metrics.jobs.cancellations, labels))),
        Match.when('process', () => Effect.void),
        Match.when('replay', () => Effect.void),
        Match.exhaustive,
      )),
      Metric.trackDuration(Metric.taggedWithLabels(metrics.jobs.processingSeconds, labels)),
      Effect.tapError((e) => {
        const errorLabels = MetricsService.label({
          job_type: config.jobType,
          reason: e.reason,
        });
        return Metric.increment(Metric.taggedWithLabels(metrics.jobs.failures, errorLabels));
      }),
    );
  });
```

**Note:**
- Match is already imported at line 6: `import { ..., Match, ... } from 'effect';`
- The helper is a pipeable combinator matching the codebase pattern (config first, effect as pipe target)
- Usage: `effect.pipe(MetricsService.trackJob({ jobType, operation, priority }))`
  </action>
  <verify>pnpm exec nx run @parametric-portal/server:typecheck</verify>
  <done>MetricsService.trackJob helper available; signature matches Plan 04-02 usage as pipeable combinator</done>
</task>

</tasks>

<verification>
1. `pnpm exec nx run @parametric-portal/server:typecheck` passes
2. Match import: `grep 'Match' packages/server/src/observe/metrics.ts | head -1` shows import
3. New metrics exist: `grep -E 'cancellations|dlqSize|processingSeconds' packages/server/src/observe/metrics.ts`
4. trackJob exists: `grep 'trackJob' packages/server/src/observe/metrics.ts` returns line
5. trackJob signature: `grep -A5 'static readonly trackJob' packages/server/src/observe/metrics.ts` shows correct config shape
6. Match.exhaustive used: `grep 'Match.exhaustive' packages/server/src/observe/metrics.ts` returns line in trackJob
</verification>

<success_criteria>
- Match import verified present in metrics.ts
- MetricsService.jobs includes: cancellations (counter), dlqSize (gauge), processingSeconds (histogram)
- MetricsService.trackJob helper exists with correct signature
- trackJob is a pipeable combinator: `(config) => (effect) => Effect`
- trackJob uses Match.exhaustive for operation dispatch
- trackJob tracks duration via processingSeconds histogram
- trackJob labels errors by reason
- All job metrics labeled consistently (job_type, priority, operation)
- Typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-job-processing/04-03-SUMMARY.md`
</output>
