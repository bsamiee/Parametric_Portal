---
phase: 04-job-processing
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - packages/server/src/observe/metrics.ts
autonomous: true

must_haves:
  truths:
    - "jobs.dlqSize gauge exists in MetricsService"
    - "jobs.cancellations counter exists in MetricsService"
    - "jobs.processingSeconds histogram exists in MetricsService"
    - "All job metrics are labeled consistently"
  artifacts:
    - path: "packages/server/src/observe/metrics.ts"
      provides: "Extended job metrics"
      contains: "dlqSize"
  key_links:
    - from: "packages/server/src/observe/metrics.ts"
      to: "effect"
      via: "Metric API"
      pattern: "Metric\\.(counter|gauge|timerWithBoundaries)"
---

<objective>
Extend MetricsService with Phase 4 job metrics.

Purpose: Job processing needs metrics for queue depth, DLQ size, cancellations, and processing duration to meet success criteria #12.
Output: Updated MetricsService with complete job.* metrics for Entity-based job processing.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-job-processing/04-RESEARCH.md
@packages/server/src/observe/metrics.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add missing job metrics to MetricsService</name>
  <files>packages/server/src/observe/metrics.ts</files>
  <action>
Extend the existing `jobs` section in MetricsService with metrics required by Phase 4 success criteria.

Current jobs metrics (already present):
- completions: counter
- deadLettered: counter
- duration: histogram
- enqueued: counter
- failures: counter
- queueDepth: gauge
- retries: counter
- waitDuration: histogram

**Add these missing metrics to the jobs object:**

```typescript
jobs: {
  // ... existing metrics ...
  cancellations: Metric.counter('jobs_cancelled_total'),
  dlqSize: Metric.gauge('jobs_dlq_size'),
  processingSeconds: Metric.timerWithBoundaries('jobs_processing_seconds', _boundaries.jobs),
},
```

Place new metrics in alphabetical order within the jobs object:
- cancellations: after completions
- dlqSize: after duration
- processingSeconds: after queueDepth (note: this is distinct from `duration` which tracks end-to-end, processingSeconds tracks active work)

The dlqSize gauge will be updated by JobEntity when jobs are dead-lettered. The cancellations counter tracks explicit cancel operations.
  </action>
  <verify>pnpm exec nx run @parametric-portal/server:typecheck</verify>
  <done>MetricsService.jobs includes cancellations, dlqSize, processingSeconds metrics</done>
</task>

<task type="auto">
  <name>Task 2: Add trackJob helper for job-specific instrumentation</name>
  <files>packages/server/src/observe/metrics.ts</files>
  <action>
Add a static helper method to MetricsService for consistent job instrumentation, following the trackCluster pattern.

**Add after trackCluster static method:**

```typescript
/** Track job operation with type and priority labels. Labels errors by type (e.reason for JobError). */
static readonly trackJob = <A, E extends { readonly reason: string }, R>(
  effect: Effect.Effect<A, E, R>,
  config: {
    readonly operation: 'submit' | 'process' | 'cancel' | 'replay';
    readonly jobType: string;
    readonly priority?: string;
  },
): Effect.Effect<A, E, R | MetricsService> =>
  Effect.flatMap(MetricsService, (metrics) => {
    const labels = MetricsService.label({
      job_type: config.jobType,
      operation: config.operation,
      priority: config.priority,
    });
    return effect.pipe(
      Effect.tap(() => Match.value(config.operation).pipe(
        Match.when('submit', () => Metric.increment(Metric.taggedWithLabels(metrics.jobs.enqueued, labels))),
        Match.when('cancel', () => Metric.increment(Metric.taggedWithLabels(metrics.jobs.cancellations, labels))),
        Match.when('process', () => Effect.void),
        Match.when('replay', () => Effect.void),
        Match.exhaustive,
      )),
      Metric.trackDuration(Metric.taggedWithLabels(metrics.jobs.duration, labels)),
      Effect.tapError((e) => {
        const errorLabels = MetricsService.label({
          job_type: config.jobType,
          reason: e.reason,
        });
        return Metric.increment(Metric.taggedWithLabels(metrics.jobs.failures, errorLabels));
      }),
    );
  });
```

Add Match to imports if not present (should already be imported for errorTag function).
  </action>
  <verify>pnpm exec nx run @parametric-portal/server:typecheck</verify>
  <done>MetricsService.trackJob helper available for job operation instrumentation</done>
</task>

</tasks>

<verification>
1. `pnpm exec nx run @parametric-portal/server:typecheck` passes
2. Verify new metrics exist: `grep -E 'cancellations|dlqSize|processingSeconds' packages/server/src/observe/metrics.ts`
3. Verify trackJob exists: `grep 'trackJob' packages/server/src/observe/metrics.ts`
</verification>

<success_criteria>
- MetricsService.jobs includes: cancellations (counter), dlqSize (gauge), processingSeconds (histogram)
- MetricsService.trackJob helper follows trackCluster pattern
- All job metrics labeled consistently (job_type, priority, operation)
- Typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-job-processing/04-03-SUMMARY.md`
</output>
