---
phase: 04-job-processing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/src/models.ts
  - packages/database/src/repos.ts
  - packages/database/migrations/0002_job_dlq.ts
autonomous: true

must_haves:
  truths:
    - "Failed jobs beyond max retries are queryable from job_dlq table with full error history"
    - "Dead-lettered jobs can be replayed via jobDlq.replay method"
    - "DLQ entries filterable by app and job type for operational triage"
  artifacts:
    - path: "packages/database/src/models.ts"
      provides: "JobDlq model class"
      contains: "class JobDlq extends Model.Class"
    - path: "packages/database/src/repos.ts"
      provides: "makeJobDlqRepo factory and DatabaseService.jobDlq"
      contains: "makeJobDlqRepo"
    - path: "packages/database/migrations/0002_job_dlq.ts"
      provides: "SQL migration for job_dlq table"
      contains: "CREATE TABLE job_dlq"
  key_links:
    - from: "packages/database/src/repos.ts"
      to: "packages/database/src/models.ts"
      via: "JobDlq import"
      pattern: "import.*JobDlq.*from.*models"
---

<objective>
Add JobDlq model and repository for dead-letter queue functionality.

Purpose: Dead-letter table enables failed jobs to be stored with full error history and replayed later. Required for Phase 4 job processing reliability.
Output: JobDlq model, repo methods, SQL migration

IMPORTANT: This plan adds a NEW JobDlq model. The existing Job model remains unchanged. The Job model already has all fields needed for job processing (status, attempts, lastError, etc). JobDlq is a separate table specifically for permanently failed jobs that need manual intervention.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-job-processing/04-RESEARCH.md
@packages/database/src/models.ts
@packages/database/src/repos.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add JobDlq model to models.ts</name>
  <files>packages/database/src/models.ts</files>
  <action>
Add a NEW JobDlq model after the existing Job model section. This is a SEPARATE model for dead-lettered jobs â€” DO NOT modify the existing Job model.

The existing Job model already has all fields needed for job processing:
- status, attempts, maxAttempts, lastError for tracking state
- payload for job data
- startedAt, completedAt for timing

JobDlq is specifically for jobs that have PERMANENTLY failed and been moved out of the active queue. Add it following existing Model.Class patterns.

JobDlq fields:
- id: Model.Generated(S.UUID) - UUIDv7 primary key
- originalJobId: S.UUID - Reference to original job
- appId: S.UUID - Tenant scope
- type: S.String - Job type for filtering
- payload: Model.JsonFromString(S.Unknown) - Original payload
- attempts: S.Number - How many times job was attempted
- errorHistory: Model.JsonFromString(S.Array(S.Struct({ error: S.String, timestamp: S.Number }))) - All errors
- failedAt: S.DateFromSelf - When job was dead-lettered
- replayedAt: Model.FieldOption(S.DateFromSelf) - When replayed (null if not replayed)

Add to exports at bottom of file.

Section comment: `// --- [JOBS: JOB_DLQ] ----------------------------------------------------------`
  </action>
  <verify>`pnpm exec nx run database:typecheck` passes</verify>
  <done>JobDlq model exists with all fields, properly exported, existing Job model unchanged</done>
</task>

<task type="auto">
  <name>Task 2: Add makeJobDlqRepo and integrate into DatabaseService</name>
  <files>packages/database/src/repos.ts</files>
  <action>
Add makeJobDlqRepo factory after makeJobRepo section:

```typescript
// --- [JOB_DLQ_REPO] ----------------------------------------------------------

const makeJobDlqRepo = Effect.gen(function* () {
  const r = yield* repo(JobDlq, 'job_dlq', {
    resolve: { byApp: 'many:appId', byType: 'many:type' },
  });
  return {
    ...r,
    byApp: (appId: string, limit: number, cursor?: string) => r.page([{ field: 'app_id', value: appId }, { field: 'replayed_at', op: 'null' }], { cursor, limit }),
    byType: (type: string, limit: number, cursor?: string) => r.page([{ field: 'type', value: type }, { field: 'replayed_at', op: 'null' }], { cursor, limit }),
    replay: (id: string) => r.set(id, { replayed_at: Update.now }),
  };
});
```

Update DatabaseService to include jobDlq:
1. Add JobDlq to imports from './models.ts'
2. Add makeJobDlqRepo to Effect.all tuple
3. Add `jobDlq` to return object
  </action>
  <verify>`pnpm exec nx run database:typecheck` passes</verify>
  <done>makeJobDlqRepo factory exists, DatabaseService.jobDlq available</done>
</task>

<task type="auto">
  <name>Task 3: Create SQL migration for job_dlq table</name>
  <files>packages/database/migrations/0002_job_dlq.ts</files>
  <action>
Create new migration file following existing 0001_initial.ts patterns.

SQL content:
```sql
CREATE TABLE job_dlq (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    original_job_id UUID NOT NULL,
    app_id UUID NOT NULL REFERENCES apps(id) ON DELETE RESTRICT,
    type TEXT NOT NULL,
    payload JSONB NOT NULL,
    attempts INTEGER NOT NULL,
    error_history JSONB NOT NULL,
    failed_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    replayed_at TIMESTAMPTZ,
    CONSTRAINT job_dlq_error_history_array CHECK (jsonb_typeof(error_history) = 'array')
);

CREATE INDEX idx_job_dlq_app ON job_dlq(app_id) WHERE replayed_at IS NULL;
CREATE INDEX idx_job_dlq_type ON job_dlq(type) WHERE replayed_at IS NULL;
CREATE INDEX idx_job_dlq_failed ON job_dlq(failed_at) WHERE replayed_at IS NULL;
```

Use same migration pattern as 0001_initial.ts with up/down exports.
  </action>
  <verify>File exists with valid SQL syntax; `pnpm exec nx run database:typecheck` passes</verify>
  <done>Migration file creates job_dlq table with indexes and constraints</done>
</task>

</tasks>

<verification>
1. `pnpm exec nx run database:typecheck` - Type checking passes
2. JobDlq model properly exported from models.ts
3. DatabaseService type includes jobDlq repo
4. Migration file has valid SQL syntax
5. Existing Job model and repo are UNCHANGED
</verification>

<success_criteria>
- JobDlq model matches schema from 04-RESEARCH.md
- Repository provides byApp, byType, replay methods
- Migration includes partial indexes for unreplayed jobs
- Existing Job model and makeJobRepo are NOT modified
</success_criteria>

<output>
After completion, create `.planning/phases/04-job-processing/04-01-SUMMARY.md`
</output>
