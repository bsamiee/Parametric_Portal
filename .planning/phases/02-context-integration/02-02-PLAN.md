---
phase: 02-context-integration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/server/src/middleware.ts
  - packages/server/src/context.ts
autonomous: true

must_haves:
  truths:
    - "HTTP requests receive cluster context without startup failures when Sharding unavailable"
    - "Cross-pod traces include runner ID and shard ID for correlation"
    - "Observability dashboards can filter by cluster.runner_id and cluster.shard_id attributes"
    - "Existing consumers of Context.Serializable continue to work (backward compatible)"
  artifacts:
    - path: "packages/server/src/middleware.ts"
      provides: "Cluster context population in makeRequestContext"
      contains: "Effect.serviceOption(Sharding.Sharding)"
    - path: "packages/server/src/context.ts"
      provides: "Extended Serializable class with cluster fields"
      contains: "runnerId: S.optional(RunnerId)"
  key_links:
    - from: "packages/server/src/middleware.ts"
      to: "@effect/cluster"
      via: "Sharding import"
      pattern: "import.*Sharding.*from '@effect/cluster'"
    - from: "packages/server/src/middleware.ts"
      to: "packages/server/src/context.ts"
      via: "makeRunnerId usage"
      pattern: "Context\\.Request\\.makeRunnerId"
    - from: "packages/server/src/context.ts"
      to: "Context.Serializable.fromData"
      via: "cluster field extraction"
      pattern: "Option.match\\(ctx.cluster"
---

<objective>
Populate cluster context in middleware and extend Serializable for cross-pod traces.

Purpose: Complete Phase 2 by wiring cluster state into HTTP request context and enabling cross-pod trace propagation. Uses graceful degradation (research-informed decision) via Effect.serviceOption to avoid startup failures when Sharding service is not yet available.
Output: Updated middleware.ts with cluster context population, extended Serializable class in context.ts.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-context-integration/02-RESEARCH.md
@.planning/phases/02-context-integration/02-CONTEXT.md
@.planning/phases/02-context-integration/02-01-SUMMARY.md
@packages/server/src/context.ts
@packages/server/src/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cluster context population to middleware</name>
  <files>packages/server/src/middleware.ts</files>
  <action>
**Dependency note:** This task requires Plan 02-01 to be complete. Verify these 3 exports exist before proceeding:
1. `ClusterState` interface (file-scoped, Plan 01 Task 1)
2. `Context.Request.ClusterState` namespace export (Plan 01 Task 2 line 188)
3. `Context.Request.makeRunnerId` static method (Plan 01 Task 2 line 195 - wraps private `_makeRunnerId`)

Add import at top of file (after existing imports):
```typescript
import { Sharding } from '@effect/cluster';
```

In makeRequestContext function, after `const tenantId = ...` line and before `const ctx: Context.Request.Data = ...`:

Add cluster context population with graceful degradation (research-informed pattern from 02-RESEARCH.md "Pitfall 2"):
```typescript
// Cluster context: graceful degradation via serviceOption
// Research note: Effect.serviceOption avoids "Service not found: Sharding" startup failures
const cluster = yield* Effect.serviceOption(Sharding.Sharding).pipe(
  Effect.flatMap(Option.match({
    onNone: () => Effect.succeed(Option.none<Context.Request.ClusterState>()),
    onSome: (s) => s.getSnowflake.pipe(
      Effect.map((sf): Option.Option<Context.Request.ClusterState> => Option.some({
        entityId: null,
        entityType: null,
        isLeader: false,
        runnerId: Context.Request.makeRunnerId(sf),
        shardId: null,
      })),
    ),
  })),
);
```

In the ctx object construction, add cluster field (alphabetical order):
```typescript
const ctx: Context.Request.Data = {
  circuit: Option.none(),
  cluster,  // NEW
  ipAddress: _extractClientIp(req.headers, req.remoteAddress),
  rateLimit: Option.none(),
  requestId,
  session: Option.none(),
  tenantId,
  userAgent: Headers.get(req.headers, 'user-agent'),
};
```

After ctx construction, add span annotation for runner ID (before return):
```typescript
yield* pipe(
  Option.flatMapNullable(cluster, (c) => c.runnerId),
  Option.match({
    onNone: () => Effect.void,
    onSome: (id) => Effect.annotateCurrentSpan('cluster.runner_id', id),
  }),
);
```

Add pipe import if not present: import { pipe } from 'effect';
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
No errors related to cluster context or Sharding imports.

```bash
grep -n "Context.Request.makeRunnerId" packages/server/src/middleware.ts
```
Confirms middleware uses the exported makeRunnerId constructor.
  </verify>
  <done>makeRequestContext populates cluster context via Effect.serviceOption with graceful degradation. Uses Context.Request.makeRunnerId for proper branded type construction. Runner ID annotated in current span when available.</done>
</task>

<task type="auto">
  <name>Task 2: Extend Serializable and toAttrs with cluster fields</name>
  <files>packages/server/src/context.ts</files>
  <action>
Extend Serializable class schema (add runnerId and shardId fields after existing fields):
```typescript
class Serializable extends S.Class<Serializable>('server/Context.Serializable')({
  ipAddress: S.optional(S.String),
  requestId: S.String,
  sessionId: S.optional(S.String),
  tenantId: S.String,
  userId: S.optional(S.String),
  // Cluster fields for cross-pod trace correlation
  // S.optional handles missing fields on decode (backward compatible with existing consumers)
  runnerId: S.optional(RunnerId),
  shardId: S.optional(ShardIdString),
}) {
```

Update Serializable.fromData to extract cluster fields:
```typescript
static readonly fromData = (ctx: Context.Request.Data): Serializable =>
  new Serializable({
    ipAddress: Option.getOrUndefined(ctx.ipAddress),
    requestId: ctx.requestId,
    tenantId: ctx.tenantId,
    ...Option.match(ctx.session, { onNone: () => ({}), onSome: (s) => ({ sessionId: s.id, userId: s.userId }) }),
    // Extract cluster fields (null -> undefined for S.optional)
    ...Option.match(ctx.cluster, {
      onNone: () => ({}),
      onSome: (c) => ({
        runnerId: c.runnerId ?? undefined,
        shardId: c.shardId ? _makeShardIdString(c.shardId) : undefined,
      }),
    }),
  });
```

Update toAttrs to include cluster fields. Add to the Record.getSomes object (after client.ua, before fiber.id):
```typescript
// Cluster fields for observability
'cluster.entity_id': Option.flatMapNullable(ctx.cluster, (c) => c.entityId),
'cluster.entity_type': Option.flatMapNullable(ctx.cluster, (c) => c.entityType),
'cluster.is_leader': Option.map(ctx.cluster, (c) => String(c.isLeader)),
'cluster.runner_id': Option.flatMapNullable(ctx.cluster, (c) => c.runnerId),
'cluster.shard_id': pipe(ctx.cluster, Option.flatMapNullable((c) => c.shardId), Option.map((s) => s.toString())),
```

Add pipe import at top if not present: check existing imports, may already have it.
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
No errors. Serializable class accepts runnerId and shardId. toAttrs returns cluster fields.
  </verify>
  <done>Context.Serializable extended with optional runnerId/shardId fields (backward compatible via S.optional). toAttrs includes cluster.* attributes for observability dashboards.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compiles without errors:
```bash
pnpm exec nx run server:typecheck
```

2. Verify cluster context population in middleware:
```bash
grep -n "Effect.serviceOption(Sharding" packages/server/src/middleware.ts
```

3. Verify middleware uses makeRunnerId (key link verification):
```bash
grep -n "Context.Request.makeRunnerId" packages/server/src/middleware.ts
```

4. Verify Serializable has cluster fields:
```bash
grep -E "runnerId:|shardId:" packages/server/src/context.ts | head -5
```

5. Verify toAttrs has cluster attributes:
```bash
grep "cluster\." packages/server/src/context.ts
```
</verification>

<success_criteria>
- makeRequestContext populates cluster context via Effect.serviceOption(Sharding.Sharding)
- Graceful degradation: Option.none() when Sharding unavailable (research-informed, avoids startup failures)
- Middleware uses Context.Request.makeRunnerId for proper branded type construction
- Runner ID annotated in current span when available
- Serializable class has optional runnerId (branded) and shardId (branded string) fields
- S.optional ensures backward compatibility (missing fields decode to undefined)
- fromData extracts cluster fields with null -> undefined conversion
- toAttrs includes cluster.* attributes (entity_id, entity_type, is_leader, runner_id, shard_id)
- TypeScript compiles without errors
- Both files remain under reasonable LOC (context.ts ~235, middleware.ts ~200)
</success_criteria>

<output>
After completion, create `.planning/phases/02-context-integration/02-02-SUMMARY.md`
</output>
