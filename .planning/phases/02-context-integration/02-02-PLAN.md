---
phase: 02-context-integration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/server/src/middleware.ts
  - packages/server/src/context.ts
autonomous: true

must_haves:
  truths:
    - "HTTP requests have cluster context populated in middleware"
    - "Cluster context degrades gracefully when Sharding service unavailable"
    - "Context.Serializable includes optional runnerId and shardId for cross-pod traces"
    - "Observability attributes include cluster fields for tracing"
  artifacts:
    - path: "packages/server/src/middleware.ts"
      provides: "Cluster context population in makeRequestContext"
      contains: "Effect.serviceOption(Sharding.Sharding)"
    - path: "packages/server/src/context.ts"
      provides: "Extended Serializable class with cluster fields"
      contains: "runnerId: S.optional(RunnerId)"
  key_links:
    - from: "packages/server/src/middleware.ts"
      to: "@effect/cluster"
      via: "Sharding import"
      pattern: "import.*Sharding.*from '@effect/cluster'"
    - from: "packages/server/src/context.ts"
      to: "Context.Serializable.fromData"
      via: "cluster field extraction"
      pattern: "Option.match\\(ctx.cluster"
---

<objective>
Populate cluster context in middleware and extend Serializable for cross-pod traces.

Purpose: Complete Phase 2 by wiring cluster state into HTTP request context and enabling cross-pod trace propagation.
Output: Updated middleware.ts with cluster context population, extended Serializable class in context.ts.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-context-integration/02-RESEARCH.md
@.planning/phases/02-context-integration/02-CONTEXT.md
@.planning/phases/02-context-integration/02-01-SUMMARY.md
@packages/server/src/context.ts
@packages/server/src/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cluster context population to makeRequestContext</name>
  <files>packages/server/src/middleware.ts</files>
  <action>
Add import at top of file (after existing imports):
```typescript
import { Sharding, Snowflake } from '@effect/cluster';
```

In makeRequestContext function, after `const tenantId = ...` line and before `const ctx: Context.Request.Data = ...`:

Add cluster context population with graceful degradation:
```typescript
// Cluster context: graceful degradation via serviceOption
const cluster = yield* Effect.serviceOption(Sharding.Sharding).pipe(
  Effect.flatMap(Option.match({
    onNone: () => Effect.succeed(Option.none<Context.Request.ClusterState>()),
    onSome: (s) => s.getSnowflake.pipe(
      Effect.map((sf): Option.Option<Context.Request.ClusterState> => Option.some({
        entityId: null,
        entityType: null,
        isLeader: false,
        runnerId: Context.Request._makeRunnerId(sf),
        shardId: null,
      })),
    ),
  })),
);
```

WAIT: _makeRunnerId is private. Need to expose it or inline the construction.

REVISED approach - inline the Snowflake conversion directly in middleware:
```typescript
// Cluster context: graceful degradation via serviceOption
const cluster = yield* Effect.serviceOption(Sharding.Sharding).pipe(
  Effect.flatMap(Option.match({
    onNone: () => Effect.succeed(Option.none<Context.Request.ClusterState>()),
    onSome: (s) => s.getSnowflake.pipe(
      Effect.map((sf): Option.Option<Context.Request.ClusterState> => Option.some({
        entityId: null,
        entityType: null,
        isLeader: false,
        runnerId: Snowflake.toString(sf) as Context.Request.RunnerId,
        shardId: null,
      })),
    ),
  })),
);
```

Wait - we need RunnerId type exposed. Let me check plan 01 - we need to export RunnerId type in namespace.

In the ctx object construction, add cluster field:
```typescript
const ctx: Context.Request.Data = {
  circuit: Option.none(),
  cluster,  // NEW
  ipAddress: _extractClientIp(req.headers, req.remoteAddress),
  rateLimit: Option.none(),
  requestId,
  session: Option.none(),
  tenantId,
  userAgent: Headers.get(req.headers, 'user-agent'),
};
```

After ctx construction, add span annotation for runner ID (before return):
```typescript
yield* pipe(
  Option.flatMapNullable(cluster, (c) => c.runnerId),
  Option.match({
    onNone: () => Effect.void,
    onSome: (id) => Effect.annotateCurrentSpan('cluster.runner_id', id),
  }),
);
```

Add pipe import if not present: import { pipe } from 'effect';
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
No errors related to cluster context or Sharding imports.
  </verify>
  <done>makeRequestContext populates cluster context via Effect.serviceOption with graceful degradation. Runner ID annotated in current span when available.</done>
</task>

<task type="auto">
  <name>Task 2: Extend Serializable and toAttrs with cluster fields</name>
  <files>packages/server/src/context.ts</files>
  <action>
First, export RunnerId type in namespace (needed by middleware). Add to Context.Request namespace:
```typescript
export type RunnerId = typeof RunnerId.Type;
```

Also export _makeRunnerId for middleware use (rename to public):
Add to Request class as static method:
```typescript
/** Create RunnerId from Snowflake (for middleware use) */
static readonly makeRunnerId = _makeRunnerId;
```

Extend Serializable class schema (add runnerId and shardId fields):
```typescript
class Serializable extends S.Class<Serializable>('server/Context.Serializable')({
  ipAddress: S.optional(S.String),
  requestId: S.String,
  sessionId: S.optional(S.String),
  tenantId: S.String,
  userId: S.optional(S.String),
  // NEW: Cluster fields (optional for backward compatibility)
  runnerId: S.optional(RunnerId),
  shardId: S.optional(ShardIdString),
}) {
```

Update Serializable.fromData to extract cluster fields:
```typescript
static readonly fromData = (ctx: Context.Request.Data): Serializable =>
  new Serializable({
    ipAddress: Option.getOrUndefined(ctx.ipAddress),
    requestId: ctx.requestId,
    tenantId: ctx.tenantId,
    ...Option.match(ctx.session, { onNone: () => ({}), onSome: (s) => ({ sessionId: s.id, userId: s.userId }) }),
    // NEW: Extract cluster fields (null -> undefined for S.optional)
    ...Option.match(ctx.cluster, {
      onNone: () => ({}),
      onSome: (c) => ({
        runnerId: c.runnerId ?? undefined,
        shardId: c.shardId ? _makeShardIdString(c.shardId) : undefined,
      }),
    }),
  });
```

Update toAttrs to include cluster fields. Add to the Record.getSomes object:
```typescript
static readonly toAttrs = (ctx: Context.Request.Data, fiberId: FiberId.FiberId): Record.ReadonlyRecord<string, string> =>
  Record.getSomes({
    'circuit.name': Option.map(ctx.circuit, (c) => c.name),
    'circuit.state': Option.map(ctx.circuit, (c) => c.state),
    'client.ip': ctx.ipAddress,
    'client.ua': Option.map(ctx.userAgent, (ua) => (ua.length > 120 ? `${ua.slice(0, 117)}...` : ua)),
    // NEW: Cluster fields
    'cluster.entity_id': Option.flatMapNullable(ctx.cluster, (c) => c.entityId),
    'cluster.entity_type': Option.flatMapNullable(ctx.cluster, (c) => c.entityType),
    'cluster.is_leader': Option.map(ctx.cluster, (c) => String(c.isLeader)),
    'cluster.runner_id': Option.flatMapNullable(ctx.cluster, (c) => c.runnerId),
    'cluster.shard_id': pipe(ctx.cluster, Option.flatMapNullable((c) => c.shardId), Option.map((s) => s.toString())),
    'fiber.id': Option.some(FiberId.threadName(fiberId)),
    'ratelimit.limit': Option.map(ctx.rateLimit, (rl) => String(rl.limit)),
    'ratelimit.remaining': Option.map(ctx.rateLimit, (rl) => String(rl.remaining)),
    'request.id': Option.some(ctx.requestId),
    'session.id': Option.map(ctx.session, (s) => s.id),
    'session.mfa': Option.map(ctx.session, (s) => String(s.mfaEnabled)),
    'tenant.id': Option.some(ctx.tenantId),
    'user.id': Option.map(ctx.session, (s) => s.userId),
  });
```

Add pipe import at top if not present: check existing imports, may already have it.
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
No errors. Serializable class accepts runnerId and shardId. toAttrs returns cluster fields.
  </verify>
  <done>Context.Serializable extended with optional runnerId/shardId fields. toAttrs includes cluster.* attributes for observability. RunnerId type exported in namespace.</done>
</task>

<task type="auto">
  <name>Task 3: Update middleware to use exported makeRunnerId</name>
  <files>packages/server/src/middleware.ts</files>
  <action>
Now that Context.Request.makeRunnerId is exported, update the cluster population in makeRequestContext to use it instead of the inline cast:

Replace the runnerId line in cluster population:
```typescript
// FROM:
runnerId: Snowflake.toString(sf) as Context.Request.RunnerId,

// TO:
runnerId: Context.Request.makeRunnerId(sf),
```

This ensures proper validation via Schema.decodeSync.
  </action>
  <verify>
```bash
pnpm exec nx run server:typecheck
```
No errors.
  </verify>
  <done>Middleware uses Context.Request.makeRunnerId for proper branded type construction.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compiles without errors:
```bash
pnpm exec nx run server:typecheck
```

2. Verify cluster context population in middleware:
```bash
grep -n "Effect.serviceOption(Sharding" packages/server/src/middleware.ts
```

3. Verify Serializable has cluster fields:
```bash
grep -E "runnerId:|shardId:" packages/server/src/context.ts | head -5
```

4. Verify toAttrs has cluster attributes:
```bash
grep "cluster\." packages/server/src/context.ts
```

5. Verify RunnerId type exported:
```bash
grep "export type RunnerId" packages/server/src/context.ts
```
</verification>

<success_criteria>
- makeRequestContext populates cluster context via Effect.serviceOption(Sharding.Sharding)
- Graceful degradation: Option.none() when Sharding unavailable (no startup failures)
- Runner ID annotated in current span when available
- Serializable class has optional runnerId (branded) and shardId (branded string) fields
- fromData extracts cluster fields with null -> undefined conversion
- toAttrs includes cluster.* attributes (entity_id, entity_type, is_leader, runner_id, shard_id)
- RunnerId type exported in Context.Request namespace
- makeRunnerId static method exposed for middleware use
- TypeScript compiles without errors
- Both files remain under reasonable LOC (context.ts ~240, middleware.ts ~200)
</success_criteria>

<output>
After completion, create `.planning/phases/02-context-integration/02-02-SUMMARY.md`
</output>
