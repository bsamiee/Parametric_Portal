---
phase: 03-shared-config-schema
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - infrastructure/src/runtime-env.ts
  - infrastructure/src/deploy.ts
autonomous: true

must_haves:
  truths:
    - "runtime-env.ts _CONFIG.config.prefixes includes EMAIL_, RESEND_, POSTMARK_, SES_, SMTP_ -- email env vars pass through to containers"
    - "runtime-env.ts _CONFIG.secrets.required.common includes RESEND_API_KEY -- default email provider's API key is treated as a required secret"
    - "runtime-env.ts _CONFIG.secrets.prefixes includes POSTMARK_ and SMTP_ -- provider tokens/passwords are captured as secrets"
    - "deploy.ts _Ops.runtime derived vars include POSTGRES_SSL set to 'true' for cloud mode and 'false' for selfhosted -- cloud RDS connections are encrypted"
    - "deploy.ts _Ops.runtime derived vars include REDIS_TLS_CA as optional passthrough for cloud mode -- ElastiCache TLS CA can be provided if Node defaults are insufficient"
  artifacts:
    - path: "infrastructure/src/runtime-env.ts"
      provides: "Email prefixes in passthrough lists, RESEND_API_KEY in required secrets"
      contains: "EMAIL_"
    - path: "infrastructure/src/deploy.ts"
      provides: "POSTGRES_SSL and REDIS_TLS_CA in derived vars"
      contains: "POSTGRES_SSL"
  key_links:
    - from: "infrastructure/src/runtime-env.ts"
      to: "packages/server/src/infra/email.ts"
      via: "Email env var passthrough -- runtime reads EMAIL_PROVIDER, RESEND_API_KEY, etc."
      pattern: "EMAIL_|RESEND_|POSTMARK_|SES_|SMTP_"
    - from: "infrastructure/src/deploy.ts"
      to: "packages/database/src/client.ts"
      via: "POSTGRES_SSL derived var -- client.ts reads Config.boolean('POSTGRES_SSL')"
      pattern: "POSTGRES_SSL"
    - from: "infrastructure/src/deploy.ts"
      to: "packages/server/src/platform/cache.ts"
      via: "REDIS_TLS_CA optional passthrough -- cache.ts reads Config.redacted('REDIS_TLS_CA')"
      pattern: "REDIS_TLS_CA"
---

<objective>
Close the three infrastructure passthrough gaps identified in the audit: email env vars missing from container passthrough, cloud mode missing POSTGRES_SSL=true derived var, and cloud mode missing REDIS_TLS_CA passthrough.

Purpose: Without these fixes, cloud deployments silently fail to send email (vars never reach the container), connect to RDS without encryption (POSTGRES_SSL defaults to false), and risk TLS handshake failures with ElastiCache (no CA certificate path). These gaps exist because runtime features (email, SSL) were added after the IaC passthrough was designed, and nobody updated the allow-lists.

Output: Modified runtime-env.ts with email prefixes/secrets, modified deploy.ts with POSTGRES_SSL and REDIS_TLS_CA derived vars.
</objective>

<execution_context>
@/Users/bardiasamiee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bardiasamiee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-shared-config-schema/03-RESEARCH.md
@infrastructure/src/runtime-env.ts
@infrastructure/src/deploy.ts
@packages/server/src/infra/email.ts
@packages/database/src/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add email env var passthrough to runtime-env.ts</name>
  <files>infrastructure/src/runtime-env.ts</files>
  <action>
Add email-related prefixes and secrets to the _CONFIG object in runtime-env.ts. Currently, runtime reads EMAIL_*, RESEND_*, POSTMARK_*, SES_*, SMTP_* vars (see email.ts lines 62-77), but none of these prefixes appear in the passthrough lists.

**Step 1: Add email prefixes to _CONFIG.config.prefixes**

The current prefixes array (line 8):
```typescript
prefixes: ['CACHE_','CLUSTER_','ENCRYPTION_','JOB_','K8S_','OTEL_','POSTGRES_','PURGE_','REDIS_','SESSION_CACHE_','STORAGE_','WEBAUTHN_','WEBHOOK_','WS_',],
```

Add these prefixes in alphabetical order: `'EMAIL_'`, `'SES_'`

The `RESEND_` prefix is NOT added to config.prefixes because RESEND_API_KEY is a secret (API key). The RESEND_ENDPOINT is a non-secret config var, but since it has a sensible default in email.ts ('https://api.resend.com/emails'), it does not need to be passthroughed unless the user explicitly sets it. If they do set it, they would need to add it via Doppler with the RESEND_ prefix -- but RESEND_ vars are mixed (API key = secret, endpoint = config). To handle this cleanly:

- Add `'RESEND_ENDPOINT'` to _CONFIG.config.allow (individual non-secret config var)
- Add `'POSTMARK_ENDPOINT'` to _CONFIG.config.allow (individual non-secret config var)

Updated config.allow (line 7):
```typescript
allow: ['API_BASE_URL','APP_NAME','CORS_ORIGINS','HOSTNAME','LOG_LEVEL','MAX_SESSIONS_PER_USER','PORT','POSTMARK_ENDPOINT','PROXY_HOPS','RATE_LIMIT_PREFIX','RATE_LIMIT_STORE','RESEND_ENDPOINT','TRUST_PROXY',],
```

Updated config.prefixes (line 8):
```typescript
prefixes: ['CACHE_','CLUSTER_','EMAIL_','ENCRYPTION_','JOB_','K8S_','OTEL_','POSTGRES_','PURGE_','REDIS_','SES_','SESSION_CACHE_','SMTP_','STORAGE_','WEBAUTHN_','WEBHOOK_','WS_',],
```

**Step 2: Add email secrets**

Add RESEND_API_KEY to secrets.required.common (it is the default provider -- a missing key causes MissingConfig error at runtime):
```typescript
common: [
    'ANTHROPIC_API_KEY', 'GEMINI_API_KEY', 'OAUTH_APPLE_PRIVATE_KEY', 'OAUTH_GITHUB_CLIENT_SECRET', 'OAUTH_GOOGLE_CLIENT_SECRET',
    'OAUTH_MICROSOFT_CLIENT_SECRET', 'OPENAI_API_KEY', 'POSTGRES_PASSWORD', 'REDIS_PASSWORD', 'RESEND_API_KEY', 'STORAGE_ACCESS_KEY_ID', 'STORAGE_SECRET_ACCESS_KEY',
],
```

Add POSTMARK_ and SMTP_ to secrets.prefixes (POSTMARK_TOKEN and SMTP_PASS are secrets, and prefix matching handles them):
```typescript
prefixes: ['OAUTH_', 'POSTMARK_', 'SMTP_'],
```

Note: RESEND_ prefix is NOT added to secrets.prefixes because the only RESEND secret is RESEND_API_KEY (already in required.common). Adding the prefix would also capture RESEND_ENDPOINT as a secret (incorrect -- it's a URL, not a credential).

**[IMPORTANT]** Maintain alphabetical order in all arrays. The existing code uses alphabetical ordering for readability.

**[IMPORTANT]** The `SMTP_` prefix in secrets.prefixes captures both SMTP_PASS (secret) and SMTP_HOST/SMTP_PORT/SMTP_USER/SMTP_SECURE/SMTP_REQUIRE_TLS (config). However, the RuntimeEnv.collect function (line 56) filters config vars with `!secretNameSet.has(name)` -- so vars matched by secret prefixes are excluded from config. This means SMTP_HOST etc. would be treated as secrets instead of config. This is acceptable because:
1. SMTP credentials are often on the same infrastructure (host+user+pass are a set)
2. K8s Secrets are the correct place for SMTP connection details (they contain auth info)
3. The alternative (splitting SMTP_ into config and secret individual entries) adds complexity without benefit

Actually, on reconsideration, this would break SMTP_HOST, SMTP_PORT, SMTP_SECURE, SMTP_REQUIRE_TLS being treated as config. These are non-secret values. Better approach:

- Add SMTP_ to config.prefixes (already done above) for SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_SECURE, SMTP_REQUIRE_TLS
- Add individual SMTP_PASS to secrets.allow
- Add individual POSTMARK_TOKEN to secrets.allow
- Do NOT add POSTMARK_ or SMTP_ to secrets.prefixes

Corrected secrets.allow:
```typescript
allow: ['DATABASE_URL', 'ENCRYPTION_KEY', 'ENCRYPTION_KEYS', 'POSTMARK_TOKEN', 'SMTP_PASS', 'STORAGE_SESSION_TOKEN'],
```

Corrected secrets.prefixes (unchanged from current):
```typescript
prefixes: ['OAUTH_'],
```

This way:
- SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_SECURE, SMTP_REQUIRE_TLS are config (matched by SMTP_ prefix in config.prefixes, not in secretNameSet)
- SMTP_PASS is a secret (in secrets.allow, added to secretNameSet, excluded from config)
- POSTMARK_TOKEN is a secret (in secrets.allow)
- POSTMARK_ENDPOINT is config (in config.allow)
- RESEND_API_KEY is a secret (in secrets.required.common)
- RESEND_ENDPOINT is config (in config.allow)
- EMAIL_PROVIDER, EMAIL_FROM, EMAIL_TIMEOUT_MS are config (matched by EMAIL_ prefix)
- SES_REGION, SES_ENDPOINT are config (matched by SES_ prefix)
  </action>
  <verify>
Run: `grep "'EMAIL_'" infrastructure/src/runtime-env.ts` -- must return a match in config.prefixes.
Run: `grep "'RESEND_API_KEY'" infrastructure/src/runtime-env.ts` -- must return a match in secrets.required.common.
Run: `grep "'POSTMARK_TOKEN'" infrastructure/src/runtime-env.ts` -- must return a match in secrets.allow.
Run: `grep "'SMTP_PASS'" infrastructure/src/runtime-env.ts` -- must return a match in secrets.allow.
Run: `grep "'SMTP_'" infrastructure/src/runtime-env.ts` -- must return a match in config.prefixes.
Run: `grep "'SES_'" infrastructure/src/runtime-env.ts` -- must return a match in config.prefixes.
Run: `grep "'RESEND_ENDPOINT'" infrastructure/src/runtime-env.ts` -- must return a match in config.allow.
Run: `grep "'POSTMARK_ENDPOINT'" infrastructure/src/runtime-env.ts` -- must return a match in config.allow.
Run: `pnpm exec nx run-many -t typecheck` -- must pass.
  </verify>
  <done>All email env vars pass through to containers. Config vars (EMAIL_*, SES_*, SMTP_HOST/PORT/USER/SECURE/REQUIRE_TLS, RESEND_ENDPOINT, POSTMARK_ENDPOINT) in config lists. Secrets (RESEND_API_KEY, POSTMARK_TOKEN, SMTP_PASS) in secret lists. No silent email failures in cloud deployments.</done>
</task>

<task type="auto">
  <name>Task 2: Add POSTGRES_SSL derived var for cloud mode</name>
  <files>infrastructure/src/deploy.ts</files>
  <action>
Add POSTGRES_SSL as a derived environment variable in the _Ops.runtime function. Cloud mode deploys to AWS RDS which supports TLS, but the runtime defaults POSTGRES_SSL to false (client.ts line 38). Without this fix, cloud database connections are unencrypted.

In _Ops.runtime (around line 116-120), after the existing REDIS_TLS derived var:
```typescript
REDIS_TLS: args.mode === 'cloud' ? 'true' : 'false',
```

Add:
```typescript
POSTGRES_SSL: args.mode === 'cloud' ? 'true' : 'false',
```

This sets POSTGRES_SSL=true for cloud deployments (enabling TLS to RDS) and POSTGRES_SSL=false for selfhosted (local postgres container without TLS).

Place it alphabetically after the POSTGRES_PORT line and before PROXY_HOPS:
```typescript
POSTGRES_HOST: args.data.dbHost,
POSTGRES_PORT: pulumi.interpolate`${args.data.dbPort}`,
POSTGRES_SSL: args.mode === 'cloud' ? 'true' : 'false',
PROXY_HOPS: args.mode === 'cloud' ? '1' : '0',
```

**[IMPORTANT]** This is a simple string value ('true'/'false'), not a pulumi.interpolate call. It does not depend on infrastructure state -- it's derived from the deployment mode.
  </action>
  <verify>
Run: `grep 'POSTGRES_SSL' infrastructure/src/deploy.ts` -- must return the derived var line.
Run: `grep "POSTGRES_SSL: args.mode === 'cloud'" infrastructure/src/deploy.ts` -- must return exactly 1 match.
Run: `pnpm exec nx run-many -t typecheck` -- must pass.
  </verify>
  <done>Cloud mode sets POSTGRES_SSL=true as derived var. RDS connections encrypted via TLS. Selfhosted mode sets POSTGRES_SSL=false (local postgres container without TLS).</done>
</task>

<task type="auto">
  <name>Task 3: Add REDIS_TLS_CA optional passthrough for cloud mode</name>
  <files>infrastructure/src/runtime-env.ts</files>
  <action>
Add REDIS_TLS_CA to the config passthrough so it can be provided via Doppler for cloud ElastiCache deployments.

**Context:** ElastiCache uses Amazon Trust Services CA. Node.js 18+ includes these CAs in its default store, so REDIS_TLS_CA is typically NOT needed. However, per research recommendation, it should be available as an optional passthrough for:
1. Custom Node.js builds without default CAs
2. Alpine containers missing ca-certificates package
3. Future CA rotations

REDIS_TLS_CA is already captured by the REDIS_ prefix in config.prefixes (line 8: `'REDIS_'`). So if a user sets REDIS_TLS_CA in Doppler, it will already pass through as a config var.

However, REDIS_TLS_CA contains a certificate -- it should be a secret, not a plain config var. The certificate itself is sensitive (reveals infrastructure topology).

Add REDIS_TLS_CA to _CONFIG.secrets.allow:
```typescript
allow: ['DATABASE_URL', 'ENCRYPTION_KEY', 'ENCRYPTION_KEYS', 'POSTMARK_TOKEN', 'REDIS_TLS_CA', 'SMTP_PASS', 'STORAGE_SESSION_TOKEN'],
```

This ensures:
1. If REDIS_TLS_CA is set in Doppler, it's captured as a Kubernetes Secret (not a ConfigMap)
2. If not set, nothing happens (it's optional in the schema with no default)
3. The REDIS_ prefix match in config.prefixes will be overridden by the secretNameSet exclusion -- the var lands in secrets, not config

**[IMPORTANT]** This does NOT add a derived var in deploy.ts. The var is user-provided via Doppler (if needed at all). The research recommends: "Default to relying on Node's CA store. Add REDIS_TLS_CA to the schema as optional."

**Also add a comment in _Ops.runtime derived vars** documenting the ElastiCache TLS assumption:
After the REDIS_TLS line in deploy.ts:
```typescript
REDIS_TLS: args.mode === 'cloud' ? 'true' : 'false',
// REDIS_TLS_CA: Not derived -- Node.js default CA store covers ElastiCache. Optional via Doppler if needed.
```

This comment goes in deploy.ts _Ops.runtime function (around line 120). It documents WHY there's no derived var, preventing future developers from thinking it's an oversight.
  </action>
  <verify>
Run: `grep 'REDIS_TLS_CA' infrastructure/src/runtime-env.ts` -- must return a match in secrets.allow.
Run: `grep 'REDIS_TLS_CA' infrastructure/src/deploy.ts` -- must return a match (the documentation comment).
Run: `pnpm exec nx run-many -t typecheck` -- must pass.
  </verify>
  <done>REDIS_TLS_CA available as optional secret passthrough for cloud ElastiCache. Node.js default CA store assumption documented in deploy.ts. No derived var needed -- user provides via Doppler if default CAs are insufficient.</done>
</task>

</tasks>

<verification>
1. `grep "'EMAIL_'" infrastructure/src/runtime-env.ts` -- email prefix in config.prefixes
2. `grep "'RESEND_API_KEY'" infrastructure/src/runtime-env.ts` -- in secrets.required.common
3. `grep "'POSTMARK_TOKEN'" infrastructure/src/runtime-env.ts` -- in secrets.allow
4. `grep "'SMTP_PASS'" infrastructure/src/runtime-env.ts` -- in secrets.allow
5. `grep 'POSTGRES_SSL' infrastructure/src/deploy.ts` -- derived var exists for cloud mode
6. `grep 'REDIS_TLS_CA' infrastructure/src/runtime-env.ts` -- in secrets.allow
7. `pnpm exec nx run-many -t typecheck` -- passes
8. No existing functionality broken -- existing env vars still pass through correctly
</verification>

<success_criteria>
- Email env vars (EMAIL_*, RESEND_*, POSTMARK_*, SES_*, SMTP_*) included in runtime-env.ts passthrough
- RESEND_API_KEY in required secrets (closes the email infrastructure gap)
- Cloud mode derives POSTGRES_SSL=true (closes the RDS encryption gap)
- REDIS_TLS_CA available as optional secret passthrough (closes the ElastiCache TLS gap)
- TypeScript compiles without errors across entire workspace
- Satisfies Phase 3 success criteria 5 (email passthrough), 6 (POSTGRES_SSL), and 7 (REDIS_TLS_CA)
</success_criteria>

<output>
After completion, create `.planning/phases/03-shared-config-schema/03-03-SUMMARY.md`
</output>
