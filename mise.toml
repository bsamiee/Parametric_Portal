# --- MISE CONFIGURATION -------------------------------------------------------
# Run: mise run <task>  |  List: mise tasks  |  Install: mise install

[settings]
experimental = true
task_output = "prefix"
jobs = 8
task_timings = true

# --- [TOOLS] ------------------------------------------------------------------
[tools]
node = "25.2.1"
pnpm = "10.26.1"

# --- [ENV] --------------------------------------------------------------------
[env]
KUBECONFIG = "{{ env.KUBECONFIG | default(value='/etc/rancher/k3s/k3s.yaml') }}"
NAMESPACE = "{{vars.NAMESPACE}}"
DOCKER_HOST = "unix://{{ env.HOME }}/.local/share/colima/default/docker.sock"
DOCKER_CERT_PATH = ""
DOCKER_TLS_VERIFY = ""

# --- [VARS] -------------------------------------------------------------------
[vars]
# Version pins
K3S_VERSION = "v1.32.11+k3s1"
K3S_VERSION_URL = "v1.32.11%2Bk3s1"
ARGOCD_VERSION = "7.8.28"
SEALED_SECRETS_VERSION = "2.17.1"
HELM_VERSION = "v3.17.0"
TRAEFIK_VERSION = "3.3.5"
NAMESPACE = "parametric-portal"

# Kustomize paths (DRY)
KUSTOMIZE_OVERLAY = "infrastructure/overlays/prod"
MANIFEST_TMP = "/tmp/k8s-manifests.yaml"

# Colima resources
COLIMA_CPU = "4"
COLIMA_MEMORY = "8"
COLIMA_DISK = "60"

# Act common flags (DRY)
ACT_FLAGS = "--container-daemon-socket - --container-architecture linux/amd64"
ACT_OFFLINE = "--action-offline-mode --artifact-server-path $PWD/.artifacts --cache-server-path $PWD/.cache"

# --- [SETUP] ------------------------------------------------------------------

[tasks.setup-k3s]
description = "Install K3s + ArgoCD + Sealed Secrets with Traefik v3"
run = '''
set -euo pipefail
log() { echo -e "\033[0;32m[INFO]\033[0m $1"; }
err() { echo -e "\033[0;31m[ERROR]\033[0m $1" >&2; }
die() { err "$1"; exit 1; }

[[ -z "${ACME_EMAIL:-}" ]] && die "ACME_EMAIL required"
[[ -z "${DOMAIN:-}" ]] && die "DOMAIN required"

command -v helm >/dev/null 2>&1 || {
    log "Installing Helm {{vars.HELM_VERSION}}..."
    HELM_TAR="helm-{{vars.HELM_VERSION}}-linux-amd64.tar.gz"
    curl -fsSL -o "/tmp/${HELM_TAR}" "https://get.helm.sh/${HELM_TAR}"
    curl -fsSL -o "/tmp/${HELM_TAR}.sha256" "https://get.helm.sh/${HELM_TAR}.sha256sum"
    (cd /tmp && sha256sum -c "${HELM_TAR}.sha256" 2>/dev/null || sha256sum -c <(grep "${HELM_TAR}" "${HELM_TAR}.sha256"))
    tar -xzf "/tmp/${HELM_TAR}" -C /tmp
    sudo install -o root -g root -m 0755 /tmp/linux-amd64/helm /usr/local/bin/helm
    rm -rf /tmp/linux-amd64 "/tmp/${HELM_TAR}" "/tmp/${HELM_TAR}.sha256"
}

log "Installing K3s {{vars.K3S_VERSION}}..."
K3S_URL="https://github.com/k3s-io/k3s/releases/download/{{vars.K3S_VERSION_URL}}"
curl -fsSL -o /tmp/k3s "${K3S_URL}/k3s"
curl -fsSL -o /tmp/sha256sum.txt "${K3S_URL}/sha256sum-amd64.txt"
(cd /tmp && grep -E "^[a-f0-9]+[[:space:]]+k3s$" sha256sum.txt | sha256sum -c -)
sudo install -o root -g root -m 0755 /tmp/k3s /usr/local/bin/k3s

cat <<'SYSTEMD' | sudo tee /etc/systemd/system/k3s.service
[Unit]
Description=Lightweight Kubernetes
Wants=network-online.target
After=network-online.target
[Install]
WantedBy=multi-user.target
[Service]
Type=notify
KillMode=process
Delegate=yes
LimitNOFILE=1048576
LimitNPROC=infinity
LimitCORE=infinity
TasksMax=infinity
Restart=always
RestartSec=5s
ExecStart=/usr/local/bin/k3s server --cluster-init --disable=servicelb --write-kubeconfig-mode=600 --secrets-encryption
SYSTEMD

sudo systemctl daemon-reload && sudo systemctl enable --now k3s
export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
kubectl wait --for=condition=Ready nodes --all --timeout=120s || die "Nodes not ready"

log "Configuring Traefik {{vars.TRAEFIK_VERSION}}..."
ACME_EMAIL_SAFE=$(printf '%s' "${ACME_EMAIL}" | sed 's/["\]/\\&/g')
sudo tee /var/lib/rancher/k3s/server/manifests/traefik-config.yaml <<EOF
apiVersion: helm.cattle.io/v1
kind: HelmChartConfig
metadata: {name: traefik, namespace: kube-system}
spec:
  valuesContent: |-
    image: {repository: docker.io/library/traefik, tag: "{{vars.TRAEFIK_VERSION}}"}
    deployment: {replicas: 1}
    resources: {requests: {cpu: 100m, memory: 128Mi}, limits: {cpu: 500m, memory: 512Mi}}
    ports:
      web: {port: 8000, expose: {default: true}, exposedPort: 80, redirectTo: {port: websecure}}
      websecure: {port: 8443, expose: {default: true}, exposedPort: 443, tls: {enabled: true}}
    ingressRoute: {dashboard: {enabled: false}}
    providers: {kubernetesCRD: {enabled: true, allowCrossNamespace: true}, kubernetesIngress: {enabled: true}}
    logs: {general: {level: INFO}, access: {enabled: true}}
    certificatesResolvers: {letsencrypt: {acme: {email: "${ACME_EMAIL_SAFE}", storage: /data/acme.json, tlsChallenge: {}}}}
    persistence: {enabled: true, size: 128Mi, path: /data}
EOF

log "Installing ArgoCD {{vars.ARGOCD_VERSION}}..."
helm repo list 2>/dev/null | grep -q "^argo[[:space:]]" || helm repo add argo https://argoproj.github.io/argo-helm
helm repo update argo
kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
helm upgrade --install argocd argo/argo-cd --namespace argocd --version "{{vars.ARGOCD_VERSION}}" \
    --set configs.cm."kustomize\\.buildOptions"="--enable-helm" --set server.service.type=ClusterIP \
    --set crds.install=true --set crds.keep=true --wait

log "Installing Sealed Secrets {{vars.SEALED_SECRETS_VERSION}}..."
helm repo list 2>/dev/null | grep -q "^sealed-secrets[[:space:]]" || helm repo add sealed-secrets https://bitnami-labs.github.io/sealed-secrets
helm repo update sealed-secrets
helm upgrade --install sealed-secrets sealed-secrets/sealed-secrets --namespace kube-system \
    --version "{{vars.SEALED_SECRETS_VERSION}}" --set fullnameOverride=sealed-secrets-controller \
    --set keyrenewperiod=720h --set resources.requests.cpu=50m --set resources.requests.memory=64Mi \
    --set resources.limits.cpu=200m --set resources.limits.memory=256Mi --wait
kubectl wait --for=condition=Available deployment/sealed-secrets-controller -n kube-system --timeout=60s
kubeseal --controller-name=sealed-secrets-controller --controller-namespace=kube-system --fetch-cert > /opt/sealed-secrets-cert.pem

log "Creating namespace {{vars.NAMESPACE}}..."
kubectl create namespace "{{vars.NAMESPACE}}" --dry-run=client -o yaml | kubectl apply -f -
kubectl apply -f - <<EOF
apiVersion: v1
kind: LimitRange
metadata: {name: default-limits, namespace: {{vars.NAMESPACE}}}
spec:
  limits:
    - type: Container
      default: {cpu: 500m, memory: 512Mi}
      defaultRequest: {cpu: 100m, memory: 128Mi}
      max: {cpu: "2", memory: 2Gi}
      min: {cpu: 50m, memory: 64Mi}
EOF

log "Setup complete! KUBECONFIG: /etc/rancher/k3s/k3s.yaml"
[[ "${SHOW_ADMIN_PASSWORD:-false}" == "true" ]] && {
    log "ArgoCD admin password:"
    kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d && echo
} || log "Run with SHOW_ADMIN_PASSWORD=true to display ArgoCD admin credentials"
'''

[tasks.seal-secret]
description = "Create SealedSecret from environment variables"
run = '''
set -euo pipefail
log() { echo -e "\033[0;32m[INFO]\033[0m $1"; }
err() { echo -e "\033[0;31m[ERROR]\033[0m $1" >&2; }
die() { err "$1"; exit 1; }

CERT="${SEALED_SECRETS_CERT:-/opt/sealed-secrets-cert.pem}"
OUT="${OUTPUT_DIR:-{{vars.KUSTOMIZE_OVERLAY}}}"
[[ -z "${1:-}" || -z "${2:-}" ]] && die "Usage: mise run seal-secret <name> <namespace>"
[[ ! -f "$CERT" ]] && die "Certificate not found: $CERT"
command -v kubeseal >/dev/null 2>&1 || die "kubeseal required"

args=()
for var in POSTGRES_USER POSTGRES_PASSWORD ENCRYPTION_KEY ANTHROPIC_API_KEY \
           OAUTH_GITHUB_CLIENT_ID OAUTH_GITHUB_CLIENT_SECRET OAUTH_GOOGLE_CLIENT_ID \
           OAUTH_GOOGLE_CLIENT_SECRET OAUTH_MICROSOFT_CLIENT_ID OAUTH_MICROSOFT_CLIENT_SECRET; do
    [[ -n "${!var:-}" ]] && args+=("--from-literal=$var=${!var}")
done
[[ ${#args[@]} -eq 0 ]] && die "No secrets in environment"

kubectl create secret generic "$1" --namespace="$2" "${args[@]}" --dry-run=client -o yaml | \
    kubeseal --cert="$CERT" --format yaml --scope namespace-wide > "${OUT}/sealed-$1.yaml"
log "Created: ${OUT}/sealed-$1.yaml"
'''

[tasks.backup-db]
description = "Backup PostgreSQL database with retention"
run = '''
set -euo pipefail
log() { echo -e "\033[0;32m[INFO]\033[0m $1"; }
err() { echo -e "\033[0;31m[ERROR]\033[0m $1" >&2; }

DIR="${BACKUP_DIR:-/opt/backups/postgres}"
DAYS="${RETENTION_DAYS:-7}"
DB="${DB_NAME:-parametric_portal}"
USER="${DB_USER:-app}"
FILE="${DIR}/${DB}_$(date +%Y%m%d_%H%M%S).sql.gz"
mkdir -p "$DIR"

log "Backing up ${DB}..."
if command -v kubectl &>/dev/null; then
    POD=$(kubectl get pods -n "{{vars.NAMESPACE}}" -l cnpg.io/cluster \
        --field-selector=status.phase=Running \
        -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
    if [[ -n "$POD" ]]; then
        kubectl exec -n "{{vars.NAMESPACE}}" "$POD" -- pg_dump -U "$USER" -d "$DB" --clean --if-exists | gzip > "$FILE"
    else
        docker exec "${CONTAINER_NAME:-postgres}" pg_dump -U "$USER" -d "$DB" --clean --if-exists | gzip > "$FILE"
    fi
else
    docker exec "${CONTAINER_NAME:-postgres}" pg_dump -U "$USER" -d "$DB" --clean --if-exists | gzip > "$FILE"
fi

find "$DIR" -name "*.sql.gz" -mtime "+${DAYS}" -delete
log "Backup: $FILE ($(du -h "$FILE" | cut -f1)), $(find "$DIR" -name "*.sql.gz" | wc -l | tr -d ' ') retained"
'''

# --- [KUBERNETES] -------------------------------------------------------------

[tasks."k8s:build"]
description = "Build Kustomize manifests"
sources = ["infrastructure/**/*.yaml"]
outputs = ["/tmp/k8s-manifests.yaml"]
run = "kustomize build {{vars.KUSTOMIZE_OVERLAY}} | tee {{vars.MANIFEST_TMP}}"

[tasks."k8s:validate"]
description = "Validate K8s manifests"
depends = ["k8s:build"]
run = "kubeconform -strict -ignore-missing-schemas -summary {{vars.MANIFEST_TMP}} && kubectl apply --dry-run=client -f {{vars.MANIFEST_TMP}} >/dev/null && echo '[OK] Manifests valid'"

[tasks."k8s:diff"]
description = "Show cluster state diff"
depends = ["k8s:build"]
run = "kubectl diff -f {{vars.MANIFEST_TMP}}; exit 0"

# --- [LINTING] ----------------------------------------------------------------

[tasks."yaml:lint"]
description = "Lint YAML files"
sources = ["infrastructure/**/*.yaml", ".github/workflows/*.yml"]
run = "yamllint infrastructure/ .github/workflows/ && echo '[OK] YAML valid'"

# --- [CONTAINER] --------------------------------------------------------------

[tasks."container:start"]
description = "Start Colima (macOS, VZ+Rosetta)"
run = """
if colima status >/dev/null 2>&1; then echo "[OK] Colima running"; colima status; exit 0; fi
echo "[INFO] Starting Colima (cpu={{vars.COLIMA_CPU}}, mem={{vars.COLIMA_MEMORY}}GB, disk={{vars.COLIMA_DISK}}GB)..."
colima start --cpu {{vars.COLIMA_CPU}} --memory {{vars.COLIMA_MEMORY}} --disk {{vars.COLIMA_DISK}} --vm-type vz --vz-rosetta
colima status
"""

[tasks."container:stop"]
description = "Stop Colima"
run = "colima status >/dev/null 2>&1 && colima stop && echo '[OK] Stopped' || echo '[OK] Not running'"

[tasks."container:status"]
description = "Show Colima status"
run = "colima status 2>/dev/null || echo '[WARN] Not running'"

# --- [WORKFLOW] ---------------------------------------------------------------

[tasks."workflow:_require-docker"]
description = "Internal: Ensure Docker available"
hide = true
run = "docker info >/dev/null 2>&1 || { echo '[ERROR] No Docker. Run: mise run container:start'; exit 1; }"

[tasks."workflow:lint"]
description = "Lint GitHub Actions workflows"
sources = [".github/workflows/*.yml"]
run = "actionlint && echo '[OK] Workflows valid'"

[tasks."workflow:list"]
description = "List workflows and jobs"
depends = ["workflow:_require-docker"]
run = "act {{vars.ACT_FLAGS}} -l"

[tasks."workflow:test"]
description = "Dry-run workflows"
depends = ["workflow:_require-docker"]
run = "act {{vars.ACT_FLAGS}} -n \"$@\""

[tasks."workflow:run"]
description = "Run workflows locally"
depends = ["workflow:_require-docker"]
run = """
mkdir -p .artifacts .cache
GH="${GITHUB_TOKEN:-${GH_TOKEN:-$(gh auth token 2>/dev/null)}}"
SECRETS="-s GITHUB_TOKEN=$GH"
[[ -n "${SONAR_TOKEN:-}" ]] && SECRETS="$SECRETS -s SONAR_TOKEN=$SONAR_TOKEN"
[[ -n "${ANTHROPIC_API_KEY:-}" ]] && SECRETS="$SECRETS -s CLAUDE_CODE_OAUTH_TOKEN=$ANTHROPIC_API_KEY"
[[ -n "${GH_PROJECTS_TOKEN:-}" ]] && SECRETS="$SECRETS -s GH_PROJECTS_TOKEN=$GH_PROJECTS_TOKEN"
echo "[INFO] Secrets: $(echo $SECRETS | sed 's/=[^ ]*/=***/g')"
act {{vars.ACT_FLAGS}} {{vars.ACT_OFFLINE}} $SECRETS "$@"
"""

[tasks."workflow:run-all"]
description = "Run all testable workflows"
depends = ["workflow:_require-docker"]
run = '''
mkdir -p .artifacts .cache
GH="${GITHUB_TOKEN:-${GH_TOKEN:-$(gh auth token 2>/dev/null)}}"
SECRETS="-s GITHUB_TOKEN=$GH"
[[ -n "${SONAR_TOKEN:-}" ]] && SECRETS="$SECRETS -s SONAR_TOKEN=$SONAR_TOKEN"
[[ -n "${ANTHROPIC_API_KEY:-}" ]] && SECRETS="$SECRETS -s CLAUDE_CODE_OAUTH_TOKEN=$ANTHROPIC_API_KEY"
[[ -n "${GH_PROJECTS_TOKEN:-}" ]] && SECRETS="$SECRETS -s GH_PROJECTS_TOKEN=$GH_PROJECTS_TOKEN"
echo "[INFO] Secrets: $(echo $SECRETS | sed 's/=[^ ]*/=***/g')"

GREEN=$'\033[0;32m'; RED=$'\033[0;31m'; NC=$'\033[0m'
run_job() { echo "${GREEN}[RUN]${NC} $1:$2"; act "$3" {{vars.ACT_FLAGS}} {{vars.ACT_OFFLINE}} $SECRETS -W ".github/workflows/$1" -j "$2" && echo "${GREEN}[OK]${NC} $2" || echo "${RED}[FAIL]${NC} $2"; }

run_job ci.yml dependency-audit push
run_job ci.yml quality push
run_job passive-qc.yml sync-labels workflow_dispatch
run_job passive-qc.yml branch-cleanup workflow_dispatch
run_job dashboard.yml update-dashboard workflow_dispatch
[[ -n "${SONAR_TOKEN:-}" ]] && run_job sonarcloud.yml Analysis workflow_dispatch
[[ -n "${ANTHROPIC_API_KEY:-}" ]] && run_job ai-maintenance.yml manual-task workflow_dispatch

echo "${GREEN}[DONE]${NC} All testable workflows executed"
echo "[INFO] Untestable locally: deploy.yml, claude.yml, claude-code-review.yml, gemini-*.yml, n8n-sync.yml"
'''
