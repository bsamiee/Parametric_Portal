# --- MISE CONFIGURATION -------------------------------------------------------
# Run: mise run <task>  |  List: mise tasks  |  Install: mise install

[settings]
experimental = true
task_output = "prefix"
jobs = 8
task_timings = true

# --- [TOOLS] ------------------------------------------------------------------
[tools]
node = "25.2.1"
pnpm = "10.26.1"

# --- [ENV] --------------------------------------------------------------------
[env]
KUBECONFIG = "{{ env.KUBECONFIG | default(value='/etc/rancher/k3s/k3s.yaml') }}"
NAMESPACE = "{{vars.NAMESPACE}}"
DOCKER_HOST = "unix://{{ env.HOME }}/.local/share/colima/default/docker.sock"
DOCKER_CERT_PATH = ""
DOCKER_TLS_VERIFY = ""
SEALED_SECRETS_CERT = "/opt/sealed-secrets-cert.pem"

# --- [VARS] -------------------------------------------------------------------
[vars]
# Version pins
K3S_VERSION = "v1.32.11+k3s1"
K3S_VERSION_URL = "v1.32.11%2Bk3s1"
K8S_VERSION = "1.32.0"
ARGOCD_VERSION = "7.8.28"
SEALED_SECRETS_VERSION = "2.17.1"
HELM_VERSION = "v3.17.0"
TRAEFIK_VERSION = "3.3.5"
NAMESPACE = "parametric-portal"

# Kustomize paths
KUSTOMIZE_OVERLAY = "infrastructure/overlays/prod"
MANIFEST_TMP = "/tmp/k8s-manifests.yaml"
KUBECONFORM_CACHE = "/tmp/kubeconform-cache"

# Colima resources (1:3 CPU:memory ratio for container workloads)
COLIMA_CPU = "4"
COLIMA_MEMORY = "12"
COLIMA_DISK = "60"

# Backup retention
RETENTION_COUNT = "10"

# Act flags (parallel jobs, new action cache, dynamic port)
ACT_FLAGS = "--container-daemon-socket - --container-architecture linux/amd64 --jobs 4"
ACT_OFFLINE = "--action-offline-mode --use-new-action-cache --artifact-server-path $PWD/.artifacts --cache-server-path $PWD/.cache --cache-server-port 0"

# --- [SETUP] ------------------------------------------------------------------

[tasks.setup-k3s]
description = "Install K3s + ArgoCD + Sealed Secrets with Traefik v3"
run = '''
set -euo pipefail
log() { echo -e "\033[0;32m[INFO]\033[0m $1"; }
err() { echo -e "\033[0;31m[ERROR]\033[0m $1" >&2; }
die() { err "$1"; exit 1; }

[[ -z "${ACME_EMAIL:-}" ]] && die "ACME_EMAIL required"
[[ -z "${DOMAIN:-}" ]] && die "DOMAIN required"

command -v helm >/dev/null 2>&1 || {
    log "Installing Helm {{vars.HELM_VERSION}}..."
    HELM_TAR="helm-{{vars.HELM_VERSION}}-linux-amd64.tar.gz"
    curl -fsSL -o "/tmp/${HELM_TAR}" "https://get.helm.sh/${HELM_TAR}"
    curl -fsSL -o "/tmp/${HELM_TAR}.sha256" "https://get.helm.sh/${HELM_TAR}.sha256sum"
    (cd /tmp && sha256sum -c "${HELM_TAR}.sha256" 2>/dev/null || sha256sum -c <(grep "${HELM_TAR}" "${HELM_TAR}.sha256"))
    tar -xzf "/tmp/${HELM_TAR}" -C /tmp
    sudo install -o root -g root -m 0755 /tmp/linux-amd64/helm /usr/local/bin/helm
    rm -rf /tmp/linux-amd64 "/tmp/${HELM_TAR}" "/tmp/${HELM_TAR}.sha256"
}

log "Configuring kernel parameters..."
sudo tee /etc/sysctl.d/90-kubelet.conf <<SYSCTL
vm.panic_on_oom=0
vm.overcommit_memory=1
kernel.panic=10
kernel.panic_on_oops=1
SYSCTL
sudo sysctl -p /etc/sysctl.d/90-kubelet.conf

log "Installing K3s {{vars.K3S_VERSION}}..."
K3S_URL="https://github.com/k3s-io/k3s/releases/download/{{vars.K3S_VERSION_URL}}"
curl -fsSL -o /tmp/k3s "${K3S_URL}/k3s"
curl -fsSL -o /tmp/sha256sum.txt "${K3S_URL}/sha256sum-amd64.txt"
(cd /tmp && grep -E "^[a-f0-9]+[[:space:]]+k3s$" sha256sum.txt | sha256sum -c -)
sudo install -o root -g root -m 0755 /tmp/k3s /usr/local/bin/k3s

cat <<'SYSTEMD' | sudo tee /etc/systemd/system/k3s.service
[Unit]
Description=Lightweight Kubernetes
Wants=network-online.target
After=network-online.target
[Install]
WantedBy=multi-user.target
[Service]
Type=notify
KillMode=process
Delegate=yes
LimitNOFILE=1048576
LimitNPROC=infinity
LimitCORE=infinity
TasksMax=infinity
TimeoutStartSec=0
TimeoutStopSec=30
MemoryMax=90%
Restart=always
RestartSec=5s
ExecStart=/usr/local/bin/k3s server --cluster-init --disable=servicelb --write-kubeconfig-mode=600 --secrets-encryption
SYSTEMD

sudo systemctl daemon-reload && sudo systemctl enable --now k3s
export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
kubectl wait --for=condition=Ready nodes --all --timeout=120s || die "Nodes not ready"

log "Configuring Traefik {{vars.TRAEFIK_VERSION}}..."
ACME_EMAIL_SAFE=$(printf '%s' "${ACME_EMAIL}" | sed 's/["\]/\\&/g')
sudo tee /var/lib/rancher/k3s/server/manifests/traefik-config.yaml <<EOF
apiVersion: helm.cattle.io/v1
kind: HelmChartConfig
metadata: {name: traefik, namespace: kube-system}
spec:
  valuesContent: |-
    image: {repository: docker.io/library/traefik, tag: "{{vars.TRAEFIK_VERSION}}"}
    global: {checkNewVersion: false, sendAnonymousUsage: false}
    deployment: {replicas: 1, terminationGracePeriodSeconds: 60}
    experimental: {fastProxy: {enabled: true, debug: false}}
    resources: {requests: {cpu: 100m, memory: 128Mi}, limits: {cpu: 500m, memory: 512Mi}}
    ports:
      web: {port: 8000, expose: {default: true}, exposedPort: 80, redirectTo: {port: websecure}}
      websecure: {port: 8443, expose: {default: true}, exposedPort: 443, tls: {enabled: true}}
    ingressRoute: {dashboard: {enabled: false}}
    providers: {kubernetesCRD: {enabled: true, allowCrossNamespace: true}, kubernetesIngress: {enabled: true}}
    logs: {general: {level: INFO}, access: {enabled: true}}
    certificatesResolvers: {letsencrypt: {acme: {email: "${ACME_EMAIL_SAFE}", storage: /data/acme.json, tlsChallenge: {}}}}
    persistence: {enabled: true, size: 128Mi, path: /data}
EOF

log "Installing ArgoCD {{vars.ARGOCD_VERSION}}..."
helm repo list 2>/dev/null | grep -q "^argo[[:space:]]" || helm repo add argo https://argoproj.github.io/argo-helm
helm repo update argo
kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
helm upgrade --install argocd argo/argo-cd --namespace argocd --version "{{vars.ARGOCD_VERSION}}" \
    --set configs.cm."kustomize\\.buildOptions"="--enable-helm" --set server.service.type=ClusterIP \
    --set crds.install=true --set crds.keep=true --wait

log "Installing Sealed Secrets {{vars.SEALED_SECRETS_VERSION}}..."
helm repo list 2>/dev/null | grep -q "^sealed-secrets[[:space:]]" || helm repo add sealed-secrets https://bitnami-labs.github.io/sealed-secrets
helm repo update sealed-secrets
helm upgrade --install sealed-secrets sealed-secrets/sealed-secrets --namespace kube-system \
    --version "{{vars.SEALED_SECRETS_VERSION}}" --set fullnameOverride=sealed-secrets-controller \
    --set keyrenewperiod=720h --set resources.requests.cpu=50m --set resources.requests.memory=64Mi \
    --set resources.limits.cpu=200m --set resources.limits.memory=256Mi --wait
kubectl wait --for=condition=Available deployment/sealed-secrets-controller -n kube-system --timeout=60s
kubeseal --controller-name=sealed-secrets-controller --controller-namespace=kube-system --fetch-cert > /opt/sealed-secrets-cert.pem

log "Creating namespace {{vars.NAMESPACE}}..."
kubectl create namespace "{{vars.NAMESPACE}}" --dry-run=client -o yaml | kubectl apply -f -
kubectl apply -f - <<EOF
apiVersion: v1
kind: LimitRange
metadata: {name: default-limits, namespace: {{vars.NAMESPACE}}}
spec:
  limits:
    - type: Container
      default: {cpu: 500m, memory: 512Mi}
      defaultRequest: {cpu: 100m, memory: 128Mi}
      max: {cpu: "2", memory: 2Gi}
      min: {cpu: 50m, memory: 64Mi}
EOF

log "Setup complete! KUBECONFIG: /etc/rancher/k3s/k3s.yaml"
[[ "${SHOW_ADMIN_PASSWORD:-false}" == "true" ]] && {
    log "ArgoCD admin password:"
    kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d && echo
} || log "Run with SHOW_ADMIN_PASSWORD=true to display ArgoCD admin credentials"
'''

[tasks.seal-secret]
description = "Create SealedSecret from environment variables"
run = '''
set -euo pipefail
log() { echo -e "\033[0;32m[INFO]\033[0m $1"; }
err() { echo -e "\033[0;31m[ERROR]\033[0m $1" >&2; }
die() { err "$1"; exit 1; }

CERT="${SEALED_SECRETS_CERT:-/opt/sealed-secrets-cert.pem}"
OUT="${OUTPUT_DIR:-{{vars.KUSTOMIZE_OVERLAY}}}"
SCOPE="${SEAL_SCOPE:-strict}"
CERT_MAX_AGE="${CERT_MAX_AGE_DAYS:-7}"

[[ -z "${1:-}" || -z "${2:-}" ]] && die "Usage: mise run seal-secret <name> <namespace>"
command -v kubeseal >/dev/null 2>&1 || die "kubeseal required"

if [[ -f "$CERT" ]]; then
    AGE=$(( ($(date +%s) - $(stat -c %Y "$CERT" 2>/dev/null || stat -f %m "$CERT")) / 86400 ))
    [[ $AGE -gt $CERT_MAX_AGE ]] && {
        log "Certificate older than ${CERT_MAX_AGE}d, refreshing..."
        kubeseal --controller-name=sealed-secrets-controller --controller-namespace=kube-system --fetch-cert > "$CERT"
    }
else
    die "Certificate not found: $CERT"
fi

args=()
for var in POSTGRES_USER POSTGRES_PASSWORD ENCRYPTION_KEY ANTHROPIC_API_KEY \
           OAUTH_GITHUB_CLIENT_ID OAUTH_GITHUB_CLIENT_SECRET OAUTH_GOOGLE_CLIENT_ID \
           OAUTH_GOOGLE_CLIENT_SECRET OAUTH_MICROSOFT_CLIENT_ID OAUTH_MICROSOFT_CLIENT_SECRET; do
    [[ -n "${!var:-}" ]] && args+=("--from-literal=$var=${!var}")
done
[[ ${#args[@]} -eq 0 ]] && die "No secrets in environment"

kubectl create secret generic "$1" --namespace="$2" "${args[@]}" --dry-run=client -o yaml | \
    kubeseal --cert="$CERT" --format yaml --scope "$SCOPE" > "${OUT}/sealed-$1.yaml"

kubeseal --validate --controller-name=sealed-secrets-controller --controller-namespace=kube-system < "${OUT}/sealed-$1.yaml" || \
    { rm -f "${OUT}/sealed-$1.yaml"; die "Validation failed"; }
log "Created and validated: ${OUT}/sealed-$1.yaml (scope: $SCOPE)"
'''

[tasks.backup-db]
description = "Backup PostgreSQL database with zstd compression"
run = '''
set -euo pipefail
log() { echo -e "\033[0;32m[INFO]\033[0m $1"; }
err() { echo -e "\033[0;31m[ERROR]\033[0m $1" >&2; }
die() { err "$1"; exit 1; }

DIR="${BACKUP_DIR:-/opt/backups/postgres}"
KEEP="${RETENTION_COUNT:-{{vars.RETENTION_COUNT}}}"
DB="${DB_NAME:-parametric_portal}"
USER="${DB_USER:-app}"
FILE="${DIR}/${DB}_$(date +%Y%m%d_%H%M%S).sql.zst"
mkdir -p "$DIR"

log "Backing up ${DB}..."
if command -v kubectl &>/dev/null; then
    POD=$(kubectl get pods -n "{{vars.NAMESPACE}}" \
        -l cnpg.io/cluster,cnpg.io/instanceRole=replica \
        --field-selector=status.phase=Running \
        -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || \
        kubectl get pods -n "{{vars.NAMESPACE}}" \
        -l cnpg.io/cluster,cnpg.io/instanceRole=primary \
        --field-selector=status.phase=Running \
        -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
    if [[ -n "$POD" ]]; then
        log "Using pod: $POD"
        kubectl exec -n "{{vars.NAMESPACE}}" "$POD" -c postgres -- \
            pg_dump -U "$USER" -d "$DB" --clean --if-exists | zstd -1 > "$FILE"
    else
        docker exec "${CONTAINER_NAME:-postgres}" pg_dump -U "$USER" -d "$DB" --clean --if-exists | zstd -1 > "$FILE"
    fi
else
    docker exec "${CONTAINER_NAME:-postgres}" pg_dump -U "$USER" -d "$DB" --clean --if-exists | zstd -1 > "$FILE"
fi

zstd -t "$FILE" || { rm -f "$FILE"; die "Backup verification failed"; }
ls -t "$DIR"/*.sql.zst 2>/dev/null | tail -n +$((KEEP + 1)) | xargs -r rm -f
log "Backup: $FILE ($(du -h "$FILE" | cut -f1)), $(find "$DIR" -name "*.sql.zst" | wc -l | tr -d ' ') retained"
'''

# --- [KUBERNETES] -------------------------------------------------------------

[tasks."k8s:build"]
description = "Build Kustomize manifests"
sources = ["infrastructure/**/*.yaml"]
outputs = ["/tmp/k8s-manifests.yaml"]
run = "kustomize build --output {{vars.MANIFEST_TMP}} --load-restrictor LoadRestrictionsNone {{vars.KUSTOMIZE_OVERLAY}}"

[tasks."k8s:validate"]
description = "Validate K8s manifests (schema + server)"
depends = ["k8s:build"]
run = """
kubeconform -strict -ignore-missing-schemas -summary \
  -n 8 -cache {{vars.KUBECONFORM_CACHE}} \
  -kubernetes-version {{vars.K8S_VERSION}} \
  {{vars.MANIFEST_TMP}} && \
kubectl apply --dry-run=server -f {{vars.MANIFEST_TMP}} >/dev/null && \
echo '[OK] Manifests valid (schema + server)'
"""

[tasks."k8s:diff"]
description = "Show cluster state diff (semantic)"
depends = ["k8s:build"]
run = "KUBECTL_EXTERNAL_DIFF='dyff between --omit-header --set-exit-code -b' kubectl diff -f {{vars.MANIFEST_TMP}} || true"

# --- [LINTING] ----------------------------------------------------------------

[tasks."yaml:lint"]
description = "Lint YAML files"
sources = ["infrastructure/**/*.yaml", ".github/workflows/*.yml"]
run = "yamllint infrastructure/ .github/workflows/ && echo '[OK] YAML valid'"

# --- [CONTAINER] --------------------------------------------------------------

[tasks."container:start"]
description = "Start Colima (macOS, VZ+Rosetta+virtiofs)"
run = """
if colima status >/dev/null 2>&1; then echo "[OK] Colima running"; colima status; exit 0; fi
echo "[INFO] Starting Colima (cpu={{vars.COLIMA_CPU}}, mem={{vars.COLIMA_MEMORY}}GB, disk={{vars.COLIMA_DISK}}GB)..."
colima start \
  --cpu {{vars.COLIMA_CPU}} \
  --memory {{vars.COLIMA_MEMORY}} \
  --disk {{vars.COLIMA_DISK}} \
  --vm-type vz \
  --vz-rosetta \
  --mount-type virtiofs \
  --cpu-type max \
  --binfmt=true
colima status
"""

[tasks."container:stop"]
description = "Stop Colima"
run = "colima status >/dev/null 2>&1 && colima stop && echo '[OK] Stopped' || echo '[OK] Not running'"

[tasks."container:status"]
description = "Show Colima status"
run = "colima status 2>/dev/null || echo '[WARN] Not running'"

# --- [WORKFLOW] ---------------------------------------------------------------

[tasks."wf:static"]
description = "Static validation (syntax + security + pinning)"
sources = [".github/workflows/*.yml"]
run = '''
set -euo pipefail
actionlint .github/workflows/*.yml && echo '[OK] actionlint'
zizmor .github/workflows/ && echo '[OK] zizmor'
ratchet lint .github/workflows/*.yml && echo '[OK] ratchet'
'''

[tasks."wf:dry-run"]
description = "Dry-run validation (job graph, no execution)"
run = '''
docker info >/dev/null 2>&1 || { echo '[SKIP] Docker not available'; exit 0; }
act {{vars.ACT_FLAGS}} --validate --strict -l && echo '[OK] Dry-run valid'
'''

[tasks."wf:check"]
description = "Full validation: static + dry-run"
depends = ["wf:static"]
run = '''
if docker info >/dev/null 2>&1; then
  act {{vars.ACT_FLAGS}} --validate --strict -l 2>&1 | head -30
  echo '[OK] Dry-run validation complete'
else
  echo '[SKIP] Docker not available, skipping dry-run'
fi
'''

[tasks."wf:trigger"]
description = "Trigger workflow on current branch"
run = '''
WORKFLOW="${1:-ci.yml}"
gh workflow run "$WORKFLOW" --ref "$(git branch --show-current)"
echo "[OK] Triggered $WORKFLOW"
'''

[tasks."wf:watch"]
description = "Watch latest workflow run until completion"
run = "gh run watch --exit-status"

[tasks."wf:status"]
description = "Show recent workflow runs"
run = "gh run list --limit 5"

[tasks."wf:debug"]
description = "View failed step logs from latest run"
run = "gh run view --log-failed"

[tasks."wf:cancel"]
description = "Cancel in-progress workflow run"
run = "gh run cancel"

[tasks."wf:rerun"]
description = "Rerun failed jobs from latest run"
run = "gh run rerun --failed"

[tasks."wf:artifacts"]
description = "Download artifacts from latest run"
run = "mkdir -p .artifacts && gh run download -D .artifacts"

[tasks."wf:test"]
description = "Test workflow: trigger + watch"
run = '''
WORKFLOW="${1:-ci.yml}"
gh workflow run "$WORKFLOW" --ref "$(git branch --show-current)"
sleep 3
gh run watch --exit-status
'''

[tasks."wf:clean"]
description = "Clean workflow artifacts and cache"
run = "rm -rf .artifacts/* .cache/* .act-secrets 2>/dev/null; echo '[OK] Cleaned'"
